{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ByteCradle 6502 Documentation","text":"<p>The ByteCradle 6502 is a single-board computer (SBC) platform built around the WDC 65C02 microprocessor.   It is designed for learning and experimenting with simple operating systems on 8-bit hardware. Whether you are new to 8-bit computers or an experienced hardware tinkerer, ByteCradle offers an accessible and expandable environment to explore these topics.</p>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"\ud83d\ude80 Getting Started <p>Learn how to assemble the board, power up safely, and run your first program.</p> \ud83d\udda5\ufe0f Hardware Overview <p>Dive deep into the hardware design, schematics, and engineering decisions behind ByteCradle.</p> \ud83d\uddb1\ufe0f Software Emulator <p>Install and use the emulator to prototype, test, and debug your 65C02 programs.</p> \ud83d\udca1 Tutorials <p>Start coding! Follow step-by-step guides for writing assembly, peripherals control, and debugging.</p> \u2699\ufe0f Advanced Topics <p>Explore system expansion, hardware mods, and building more sophisticated applications.</p>"},{"location":"getting-started/assembling-the-board/","title":"Assembling the Board","text":""},{"location":"getting-started/assembling-the-board/#flashing-the-rom","title":"Flashing the ROM","text":"<p>Before powering up your ByteCradle board for the first time, it's essential to flash the appropriate ROM image onto the onboard memory chip. The required ROM chip and image depend on the variant of the board:</p> <ul> <li>ByteCradle Tiny: Uses an SST39SF010 (1 Mbit) chip.</li> <li>ByteCradle Mini: Uses an SST39SF040 (4 Mbit) chip.</li> </ul> <p>Each board requires a specific ROM file that matches its hardware configuration.</p>"},{"location":"getting-started/assembling-the-board/#required-tools","title":"Required Tools","text":"<p>To flash the ROM, you'll need a compatible EPROM/Flash programmer. Options include:</p> <ul> <li>Commercial Programmers:<ul> <li>TL866II Plus: A popular, affordable universal programmer.</li> <li>XGecu T48: A more advanced model supporting a wide range of devices.</li> </ul> </li> <li>Open Source and DIY Alternatives:<ul> <li>Pico-SST39SF0x0 Programmer: A lightweight and affordable programmer using a Raspberry Pi Pico.</li> <li>Arduino-based Flashers: Utilize an Arduino (e.g., Uno) with community firmware for programming simple parallel flash devices.</li> </ul> </li> </ul> <p>Choosing a Flasher</p> <p>Commercial programmers offer ready-to-use software and broad device support. However, open-source solutions like the Pico-SST39SF0x0 Programmer are cost-effective and excellent for DIY enthusiasts.</p>"},{"location":"getting-started/assembling-the-board/#flashing-process-overview","title":"Flashing Process Overview","text":"<ol> <li> <p>Set Up the Programmer:</p> <ul> <li>For the Pico-SST39SF0x0 Programmer:</li> <li>Flash your Raspberry Pi Pico with the firmware from the GitHub repository.</li> <li>Connect the ROM chip to the Pico according to the wiring guide provided in the repository.</li> </ul> </li> <li> <p>Load the ROM File:</p> <ul> <li>Open your flashing software.</li> <li>Select the correct chip type from the supported devices list.</li> <li>Load the appropriate ROM image for your ByteCradle board variant.</li> </ul> </li> <li> <p>Write and Verify:</p> <ul> <li>Erase the chip if necessary (some programmers do this automatically).</li> <li>Write the ROM file to the flash chip.</li> <li>Perform a verification pass to confirm the write was successful.</li> </ul> </li> <li> <p>Install the ROM:</p> <ul> <li>After successful flashing, insert the ROM chip carefully into its socket, ensuring correct orientation.</li> </ul> </li> </ol> <p>Once the ROM is programmed and installed, you're ready to proceed with the first power-up!</p>"},{"location":"getting-started/first-power-up/","title":"First Power-Up and Testing","text":""},{"location":"getting-started/first-power-up/#hooking-up-the-power-supply","title":"Hooking up the Power Supply","text":"<p>The ByteCradle board requires a 5V power supply capable of delivering at least 500 mA of current. Power is supplied through a USB-B connector. The ByteCradle does not have any on-board power regulation. It is critical to use a reliable and regulated 5V power source to avoid damaging the board. Recommended options include:</p> <ul> <li>A direct connection to a computer USB port</li> <li>A certified USB wall adapter rated for 5V output</li> </ul> <p>Power Supply Safety</p> <p>Avoid using low-quality or unregulated power adapters, as unstable voltages can cause erratic behavior or permanent damage to the board.</p> <p>Power-Up Sequence</p> <p>Before powering up the board, make sure the serial communication cable (see next section) is connected and a serial port has been opened on your computer. This ensures you will see the header information that the board outputs upon boot. If you power on the board before setting up the serial connection, you can still communicate with it, but you will miss the initial startup messages. In that case, simply press the reset button on the board to perform a cold boot and re-trigger the startup sequence.</p>"},{"location":"getting-started/first-power-up/#setting-up-serial-communication","title":"Setting Up Serial Communication","text":"<p>Communication with the ByteCradle platform is handled via a standard RS232 serial interface, implemented using the onboard 65C51 ACIA (Asynchronous Communications Interface Adapter) and a MAX232 line driver. This setup ensures reliable and straightforward serial communication, supporting both TTL and RS232 voltage levels.</p> <p>The default communication settings are:</p> <ul> <li>Baud Rate: 115200</li> <li>Data Bits: 8</li> <li>Parity: None</li> <li>Stop Bits: 1</li> </ul> <p>(commonly referred to as 8N1 configuration).</p> <p>Several tools are available to interface with the board over RS232:</p> <ul> <li>Windows: PuTTY, Tera   Term</li> <li>MacOS: CoolTerm, or the built-in   <code>screen</code> command</li> <li>Linux: Minicom, <code>screen</code>, or   picocom</li> </ul> <p>Finding the correct serial port</p> <ul> <li>On Windows: Open Device   Manager and look under Ports (COM &amp; LPT). Your device will appear as   something like <code>COM3</code>, <code>COM4</code>, etc. </li> <li>On MacOS: Use the command <code>ls /dev/tty.*</code> in Terminal. Look for entries like <code>/dev/tty.usbserial-XXXXX</code>. </li> <li>On Linux: Use <code>ls /dev/ttyUSB*</code> or <code>ls /dev/ttyACM*</code> depending on your   USB-to-serial adapter. Common examples include <code>/dev/ttyUSB0</code>.</li> </ul> <p>Connection Tip</p> <p>After identifying the correct port, configure your terminal program with the settings above and open the connection. Upon powering up the ByteCradle, you should see output from the board if the connection is established correctly.</p>"},{"location":"hardware/board-overview/","title":"Board Overview","text":""},{"location":"hardware/board-overview/#tier-system-overview","title":"Tier System Overview","text":"<p>The platform currently consists of two distinct tiers, each targeting different levels of complexity:</p>"},{"location":"hardware/board-overview/#tiny-sbc","title":"Tiny SBC","text":"<ul> <li>Simplified design with a small footprint.</li> <li>Memory: 32 KiB RAM and 32 KiB ROM.</li> <li>Programmable logic: Utilizes small PLDs to minimize discrete components.</li> <li>Ideal for learning, experimentation, and small embedded projects.</li> </ul>"},{"location":"hardware/board-overview/#mini-sbc","title":"Mini SBC","text":"<ul> <li>Advanced design with bank switching for greater memory capabilities.</li> <li>Memory: 512 KiB of RAM and 512 KiB of ROM (bank-switched).</li> <li>Programmable logic: Built around CPLDs for greater integration.</li> <li>Includes a 65C22 VIA to interface with an SD card for persistent   storage and potential peripheral expansion.</li> <li>Perfect for exploring larger applications, file systems, and   system-level programming.</li> </ul>"},{"location":"hardware/board-overview/#feature-comparison","title":"Feature Comparison","text":"Feature Tiny SBC Mini SBC RAM 32 KiB 512 KiB (bank switched) ROM 32 KiB 512 KiB (bank switched) Bank Switching \u274c \u2705 (64 \u00d7 8 KiB banks) SD Card Support \u274c \u2705 (via 65C22 VIA) I/O Interface 65C51 ACIA 65C51 ACIA Expansion Options Exposes system bus Exposes system bus and VIA bus"},{"location":"hardware/memory-maps/","title":"Memory Maps","text":""},{"location":"hardware/memory-maps/#tiny-board","title":"Tiny Board","text":"<p>The Tiny Board uses a flat 64 KiB memory map typical of 65C02-based systems. The first 256 bytes (<code>$0000\u2013$00FF</code>) are Zero Page RAM, followed by the stack at <code>$0100\u2013$01FF</code>. The range <code>$0200\u2013$03FF</code> is reserved for OS use, while <code>$0400\u2013$7EFF</code> serves as general-purpose RAM.</p> <p>A small I/O region at <code>$7F00\u2013$7FFF</code> includes only <code>$7F04\u2013$7F07</code>, which is connected to a 65C51 ACIA UART for serial communication. The remainder of the I/O space is currently unused but mapped to RAM, meaning it is technically accessible for reads and writes. However, using this area is not recommended, as future hardware revisions may repurpose it. Users may also reconfigure the address decoding logic by updating the ATF22V10 chip to change or expand the I/O mapping as needed.</p> <p>The upper 32 KiB (<code>$8000\u2013$FFFF</code>) is mapped to ROM, containing system firmware such as a monitor or BASIC interpreter.</p> Address Range Size Description <code>$0000-$00FF</code> 256 bytes Zero Page RAM <code>$0100-$01FF</code> 256 bytes Stack <code>$0200-$03FF</code> 512 bytes Reserved (OS Use) <code>$0400-$7EFF</code> ~31 KiB General Purpose RAM <code>$7F00-$7F03</code> 4 bytes Unused / Reserved <code>$7F04-$7F07</code> 4 bytes ACIA (UART) <code>$7F08-$7FFF</code> 248 bytes Unused / Reserved <code>$8000-$FFFF</code> 32 KiB ROM"},{"location":"hardware/memory-maps/#mini-board","title":"Mini Board","text":"<p>The Mini Board features a flexible 64 KiB memory map designed to support both fixed and bank-switched memory regions. The lower memory (<code>$0000\u2013$7EFF</code>) is primarily RAM, with the first 256 bytes (<code>$0000\u2013$00FF</code>) allocated as Zero Page, and the next 256 bytes (<code>$0100\u2013$01FF</code>) serving as the stack. Addresses <code>$0200\u2013$03FF</code> are reserved for OS-level functionality, while the remainder up to <code>$7EFF</code> is available as general-purpose RAM, implemented across fixed banks 0\u20133.</p> <p>The region <code>$7F00\u2013$7FFF</code> is dedicated to memory-mapped I/O, divided into four 64-byte blocks using only address lines A6 and A7. The first block (<code>$7F00\u2013$7F3F</code>) connects to a 65C51 ACIA for serial communication, while the second (<code>$7F40\u2013$7F7F</code>) maps to a 6522 VIA. The remaining two blocks (<code>$7F80\u2013$7FBF</code> and <code>$7FC0\u2013$7FFF</code>) are used to write to the ROM and RAM bank registers, respectively.</p> <p>The upper half of the address space is split between banked and fixed ROM/RAM. The ranges <code>$8000\u2013$9FFF</code> and <code>$A000\u2013$BFFF</code> are bank-switched RAM and ROM windows, supporting 64 banks each. The final 16 KiB (<code>$C000\u2013$FFFF</code>) is mapped to fixed ROM, permanently connected to banks 0 and 1, typically containing system firmware.</p> <p>Warning</p> <p>The bank-switched ROM and RAM regions (<code>$A000\u2013$BFFF</code> and <code>$8000\u2013$9FFF</code>) share the same physical memory space as the fixed ROM (<code>$C000\u2013$FFFF</code>) and fixed RAM (<code>$0000\u2013$7EFF</code>), respectively. This means that selecting ROM banks 0\u20131 or RAM banks 0\u20133 will expose the same physical memory already mapped in the fixed regions. For example, if RAM bank 0 is selected, writes may unintentionally modify the stack or zero page; selecting ROM bank 0 might interfere with the interrupt vectors or firmware routines.  </p> <p>While overlapping ROM banks are less problematic\u2014since ROM is typically read-only and cannot be written to\u2014it can still cause confusion or redundancy if the same code or data appears in both fixed and banked areas. It is strongly recommended to begin using RAM banks from 4 upwards and ROM banks from 2 upwards to avoid overlapping with fixed memory areas and ensure predictable behavior.</p> Address Range Size Description <code>$0000-$00FF</code> 256 bytes Zero Page RAM <code>$0100-$01FF</code> 256 bytes Stack <code>$0200-$03FF</code> 512 bytes Reserved (OS Use) <code>$0400-$7EFF</code> ~31 KiB General Purpose RAM (Fixed, Banks 0\u20133) <code>$7F00-$7F3F</code> 64 bytes ACIA (UART) <code>$7F40-$7F7F</code> 64 bytes VIA <code>$7F80-$7FBF</code> 64 bytes ROM Bank Register <code>$7FC0-$7FFF</code> 64 bytes RAM Bank Register <code>$8000-$9FFF</code> 8 KiB Bank-switched RAM Window (Banks 0\u201363) <code>$A000-$BFFF</code> 8 KiB Bank-switched ROM Window (Banks 0\u201363) <code>$C000-$FFFF</code> 16 KiB Fixed ROM (Banks 0\u20131 mapped permanently)"},{"location":"introduction/what-is-platform/","title":"Introducing the ByteCradle 6502 Platform","text":"<p>The ByteCradle 6502 is a hands-on, 8-bit computing platform built around the WDC 65C02 microprocessor. It is designed for hobbyists, educators, and retrocomputing enthusiasts who want to dive into low-level system design, assembly programming, and hardware experimentation.</p> <p>The platform intentionally keeps the chip count low, using programmable logic devices (PLDs) and complex programmable logic devices (CPLDs) to simplify circuitry while maintaining expandability and flexibility.</p>"},{"location":"introduction/what-is-platform/#tier-system-overview","title":"Tier System Overview","text":"<p>The platform currently consists of two distinct tiers, each targeting different levels of complexity:</p>"},{"location":"introduction/what-is-platform/#tiny-sbc","title":"Tiny SBC","text":"<ul> <li>Simplified design with a small footprint.</li> <li>Memory: 32 KiB RAM and 32 KiB ROM.</li> <li>Programmable logic: Utilizes small PLDs to minimize discrete components.</li> <li>Ideal for learning, experimentation, and small embedded projects.</li> </ul>"},{"location":"introduction/what-is-platform/#mini-sbc","title":"Mini SBC","text":"<ul> <li>Advanced design with bank switching for greater memory capabilities.</li> <li>Memory: 512 KiB of RAM and 512 KiB of ROM (bank-switched).</li> <li>Programmable logic: Built around CPLDs for greater integration.</li> <li>Includes a 65C22 VIA to interface with an SD card for persistent   storage and potential peripheral expansion.</li> <li>Perfect for exploring larger applications, file systems, and   system-level programming.</li> </ul>"},{"location":"introduction/why-65c02/","title":"Why the 65C02?","text":"<p>The choice of the WDC 65C02 as the core processor for the ByteCradle platform is deliberate and based on technical, historical, and practical considerations.</p>"},{"location":"introduction/why-65c02/#historical-significance","title":"Historical Significance","text":"<p>The 6502 microprocessor family has played a pivotal role in the history of computing. Introduced in 1975 by MOS Technology, the 6502 quickly became known for its simplicity, affordability, and effectiveness. It powered many influential computing systems of the late 1970s and 1980s, including:</p> <ul> <li>The Commodore 64</li> <li>The Apple II series</li> <li>The Atari 8-bit computers</li> <li>Early game consoles such as the Nintendo Entertainment System (via a 6502   derivative)</li> </ul> <p>The 6502 architecture became a foundation for both educational and commercial computing, introducing many engineers to low-level system design and programming. Choosing a 6502-based system connects users directly with these historical roots, providing a platform to understand the fundamental design principles that shaped modern computing.</p>"},{"location":"introduction/why-65c02/#ongoing-availability","title":"Ongoing Availability","text":"<p>Unlike many processors from the same era, the 65C02 is still in production today, manufactured by the Western Design Center (WDC). This continued availability ensures:</p> <ul> <li>Reliable sourcing from multiple vendors.</li> <li>Use of modern fabrication techniques, increasing consistency and reducing   power consumption.</li> <li>Long-term support for educational and experimental projects.</li> </ul> <p>This availability makes the 65C02 a practical choice for a new hardware platform, avoiding the need to rely on discontinued or obsolete components.</p>"},{"location":"introduction/why-65c02/#advantages-of-the-65c02","title":"Advantages of the 65C02","text":"<p>The 65C02 is a CMOS version of the original NMOS 6502, bringing several improvements while maintaining compatibility with the original architecture:</p> <ul> <li> <p>Higher clock frequencies:   The CMOS design allows the 65C02 to operate reliably at significantly higher   clock speeds than the original 6502.</p> </li> <li> <p>Reduced power consumption:   CMOS fabrication reduces energy requirements, making the system more efficient   and better suited for modern embedded or battery-powered applications.</p> </li> <li> <p>Expanded instruction set and corrections:   The 65C02 adds new instructions, removes some undefined behaviors of the   original 6502, and introduces small enhancements that simplify system   programming.</p> </li> </ul> <p>These technical improvements result in a processor that maintains historical relevance while providing better performance, reliability, and usability for contemporary designs.</p>"},{"location":"introduction/why-65c02/#summary","title":"Summary","text":"<p>The selection of the 65C02 for the ByteCradle platform reflects a balance between historical appreciation and practical engineering:</p> <ul> <li>It connects users with the foundations of 8-bit computing.</li> <li>It provides a readily available, robust, and energy-efficient processor.</li> <li>It allows exploration of both classic and expanded 6502 programming   techniques.</li> </ul> <p>By using the 65C02, the platform offers a reliable and instructive environment for studying fundamental computer engineering concepts on real hardware.</p>"},{"location":"tutorials/debugging/","title":"Debugging","text":""},{"location":"tutorials/inline-assembler/","title":"Monitor","text":"<p>The MONITOR is a simple program that provides direct control over the system\u2019s memory and CPU execution. It allows you to read and write memory, run code from specific addresses, assemble instructions manually, and disassemble machine code for inspection.</p> <p>Note</p> <p>The description provided here pertains to the <code>/TINY/</code> board, but the instructions are transferable to the <code>/MINI/</code> board. The major difference is that the <code>/MINI/</code> board supports bank switching and has its ROM starting at <code>0xC000</code> where as the <code>/TINY/</code> has ROM starting at <code>0x8000</code>.</p> <p>Upon booting the <code>/TINY/</code> board, you will be greeted with a selection menu which allows you to select the <code>MONITOR</code> option. </p> <pre><code>+----------------------------------------------+\n|             BYTECRADLE MONITOR               |\n+----------------------------------------------+\n| FREE ZERO PAGE :     0x40 - 0xFF             |\n| FREE RAM       : 0x0400 - 0x7F00             |\n| ROM            : 0x8000 - 0xFFFF             |\n+----------------------------------------------+\n| COMMANDS                                     |\n| R&lt;XXXX&gt;[:&lt;XXXX&gt;] read memory                 |\n| W&lt;XXXX&gt;          write to memory             |\n| G&lt;XXXX&gt;          run from address            |\n| A&lt;XXXX&gt;          assemble from address       |\n| D&lt;XXXX&gt;          disassemble from address    |\n| M                show this menu              |\n| Q                quit                        |\n+----------------------------------------------+\n</code></pre>"},{"location":"tutorials/inline-assembler/#monitor-functions","title":"Monitor Functions","text":"<p>The Monitor provides several commands that allow direct interaction with the system's memory and CPU. These functions are essential for writing, testing, and debugging programs at a low level:</p> <ul> <li>Reading memory (<code>R&lt;XXXX&gt;[:&lt;XXXX&gt;]</code>) Allows you to examine memory contents at a   specific address or within a range of addresses.</li> <li>Writing to memory (<code>W&lt;XXXX&gt;</code>) Enables manual modification of memory contents at   a given address. Useful for inserting data like ASCII strings or instructions.</li> <li>Running code (<code>G&lt;XXXX&gt;</code>) Starts execution of code from a specific memory   address, enabling you to run programs you have written or loaded into RAM.</li> <li>Inline assembly (<code>A&lt;XXXX&gt;</code>) Opens an assembler interface at the specified   address, allowing you to input machine code instructions directly in mnemonic   form.</li> <li>Disassembling code (<code>D&lt;XXXX&gt;</code>) Reads machine code from memory and converts it   back into human-readable assembly instructions.</li> <li>Showing the menu (<code>M</code>) Displays the monitor\u2019s command menu and current memory   layout for quick reference.</li> <li>Quitting (<code>Q</code>) Exits the monitor and returns control to the system selection   menu or operating environment.</li> </ul> <p>These functions work together to provide a lightweight but powerful development environment directly on the hardware.</p>"},{"location":"tutorials/inline-assembler/#sample-programs","title":"Sample programs","text":"<p>The following examples demonstrate how to use the Monitor\u2019s inline assembler, memory writing, and program execution features. By manually assembling instructions and inserting data, you can create simple programs directly in memory and run them without needing external tools. These exercises are ideal for learning how the system interacts with memory and the CPU at a low level.</p>"},{"location":"tutorials/inline-assembler/#hello-world","title":"Hello World","text":"<p>Open the inline-assembler using <code>A0400</code> and insert the following assembly instructions:</p> <pre><code>0400: LDA #10       A9 10\n0402: LDX #04       A2 04\n0404: JSR FFE8      20 E8 FF\n0407: RTS           60\n</code></pre> <p>Next, insert the ASCII characters for the string <code>Hello World!</code> by first typing <code>W0410</code> and entering the following values:</p> <pre><code>0410: 48 65 6C 6C 6F 20 57 6F 72 6C 64 21 00\n</code></pre> <p>To run the small program, type <code>G0400</code>.</p> <p>The expected output is:</p> <pre><code>@:G0400\nHello World!\n</code></pre>"},{"location":"tutorials/inline-assembler/#fibonacci-series","title":"Fibonacci series","text":"<p>Open the inline-assembler using <code>A0400</code> and insert the following assembly instructions:</p> <pre><code>0400: LDA #01                  A9 01\n0402: LDX #01                  A2 01\n0404: LDY #00                  A0 00\n0406: PHX                      DA\n0407: PHY                      5A\n0408: JSR FFF4                 20 F4 FF\n040B: JSR FFEE                 20 EE FF\n040E: PLY                      7A\n040F: PLX                      FA\n0410: STX 40                   86 40\n0412: CLC                      18\n0413: PHA                      48\n0414: ADC 40                   65 40\n0416: PLX                      FA\n0417: INY                      C8\n0418: CPY #0C                  C0 0C\n041A: BNE EA                   D0 EA\n041C: RTS                      60\n</code></pre> <p>Note</p> <p>The value of <code>$40</code> used for <code>STX 40</code> and <code>ADC 40</code> refer to zero page address <code>$40</code>. Note that we are only allowed to use zero page addresses starting from <code>$40</code> as everything below is used by the system (including the monitor).</p> <p>To run the program, type <code>G0400</code>, which yields the following output:</p> <pre><code>@:G0400\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n</code></pre>"},{"location":"tutorials/peripherals/","title":"Working with peripherals","text":""}]}