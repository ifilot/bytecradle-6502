{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ByteCradle 6502 Documentation","text":"<p>The ByteCradle 6502 is a single-board computer (SBC) platform built around the WDC 65C02 microprocessor.   It is designed for learning and experimenting with simple operating systems on 8-bit hardware. Whether you are new to 8-bit computers or an experienced hardware tinkerer, ByteCradle offers an accessible and expandable environment to explore these topics.</p>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"\ud83d\ude80 Getting Started <p>Learn how to assemble the board, power up safely, and run your first program.</p> \ud83d\udda5\ufe0f Hardware Overview <p>Dive deep into the hardware design, schematics, and engineering decisions behind ByteCradle.</p> \ud83d\udcbe Software Overview <p>Explore the codebase and development decisions that power ByteCradle's software stack.</p> \ud83e\uddea Emulator <p>Install and use the emulator to prototype, test, and debug your 65C02 programs.</p> \ud83d\udca1 Tutorials <p>Start coding! Follow step-by-step guides for writing assembly, peripherals control, and debugging.</p> \u2699\ufe0f Advanced Topics <p>Explore system expansion, hardware mods, and building more sophisticated applications.</p>"},{"location":"emulator/emulator-overview/","title":"Emulator Overview","text":"<p>Developing software for the ByteCradle 6502 platform without an emulator involves a tedious and repetitive workflow: you would need to cross-assemble or cross-compile your source code, flash it onto a ROM, physically insert that ROM into the board, and then run the board to test your code. Each cycle can take several minutes and is prone to errors, making rapid development and testing difficult.</p> <p>The <code>bc6502emu</code> emulator removes these barriers by allowing you to run and test your 6502 code directly on a modern computer. It integrates cleanly into your development workflow and enables fast iteration without the need for physical hardware during the early stages of development.</p>"},{"location":"emulator/emulator-overview/#benefits-of-using-an-emulator","title":"Benefits of Using an Emulator","text":"<ul> <li>Rapid testing and iteration: Instantly test code changes without flashing or hardware interaction, dramatically reducing development time.</li> <li>Safe and controlled environment: Reproducible and isolated, ideal for debugging, testing edge cases, and avoiding hardware wear or damage.</li> <li>Simplified debugging: Observe program behavior, simulate input, and analyze results using standard tools on your development machine.</li> <li>Development without hardware: Start writing and validating software even before hardware is available or finalized.</li> <li>Automation and integration: Easily integrate into build systems and CI pipelines for automated testing and validation.</li> </ul>"},{"location":"emulator/emulator-overview/#introducing-bc6502emu","title":"Introducing <code>bc6502emu</code>","text":"<p><code>bc6502emu</code> is a lightweight emulator designed specifically for the ByteCradle 6502 platform. It supports the two board variants:</p> <ul> <li>tiny \u2013 a minimal configuration without SD card storage.</li> <li>mini \u2013 includes SD card image support for simulating file I/O and the 65C22 versatile interface adapter.</li> </ul> <p>With <code>bc6502emu</code>, you can:</p> <ul> <li>Run 6502 binaries directly from your development environment.</li> <li>Simulate SD card behavior (mini variant).</li> <li>Configure the emulated CPU clock speed.</li> <li>Provide terminal input for programs that rely on user interaction.</li> </ul> <p>Ready to get started?</p> <p>Go to the Installing Emulator page to compile and run the emulator.</p>"},{"location":"emulator/installing-emulator/","title":"Installing and Running the Emulator","text":"<p>This guide explains how to compile and run the <code>bc6502emu</code> emulator on a modern POSIX-compatible system. The emulator supports both the <code>tiny</code> and <code>mini</code> variants of the ByteCradle 6502 board and is designed for fast and simple command-line usage.</p>"},{"location":"emulator/installing-emulator/#platform-requirements","title":"Platform Requirements","text":"<p>We assume you are working in a POSIX environment, such as Linux or macOS. For Windows users, we warmly recommend installing  Windows Subsystem for Linux (WSL). All development and testing have been done using Ubuntu, and we recommend it as the reference environment.</p>"},{"location":"emulator/installing-emulator/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure your system meets the following requirements:</p> <ul> <li>A C++17-compatible compiler</li> <li>CMake for managing the build process</li> <li>The TCLAP library for command-line parsing</li> </ul> <p>To install all required dependencies on Ubuntu or Debian-based systems, run:</p> <pre><code>sudo apt update &amp;&amp; sudo apt install build-essential cmake libtclap-dev\n</code></pre> <p>After compilation, the emulator binary will be located in the <code>build</code> directory under the name <code>bc6502emu</code>.</p> <p>Ready to start using the emulator?</p> <p>Go to the Running the Emulator</p>"},{"location":"emulator/running-emulator/","title":"Running the Emulator","text":"<p>Once compiled, you can run the emulator with the following syntax (adjust accordingly for your paths):</p> <pre><code>./bc6502emu --board &lt;tiny|mini&gt; \\\n--rom &lt;path_to_rom&gt; \\\n[--sdcard &lt;path_to_sdcard&gt;] \\\n[--clock &lt;mhz&gt;]\n</code></pre>"},{"location":"emulator/running-emulator/#arguments","title":"Arguments","text":"Argument Description Required <code>-b, --board</code> Select the board type: <code>tiny</code> or <code>mini</code>. Yes <code>-r, --rom</code> Path to the ROM file to load. Yes <code>-s, --sdcard</code> Path to the SD card image (only for <code>mini</code>). No <code>-c, --clock</code> CPU clock speed in MHz (default: 16.0 MHz). No"},{"location":"emulator/running-emulator/#example-usage","title":"Example Usage","text":"<p>To run the emulator with the <code>tiny</code> board:</p> <pre><code>./bc6502emu --board tiny --rom ../../src/tinyrom/tinyrom.bin\n</code></pre> <p>To run the emulator with the <code>mini</code> board and an SD card image:</p> <pre><code>./bc6502emu --board mini --rom ../../src/minirom.bin --sdcard ../scripts/sdcard.img --clock 12.0\n</code></pre> <p>Info</p> <p>For running the <code>/MINI/</code> board, besides the ROM file, you will also need an SD-card image. This SD-card image can be generated using the <code>create_sd.sh</code> script found in the <code>emulator/script</code> folder.</p> <p>Tip</p> <p>For compiling the ROMs, we make use of a <code>Makefile</code>. These <code>Makefile</code> files contain the <code>make run</code> instruction which automatically launches the ROM in the emulator using the right settings. It does assume that the emulator has been compiled in the <code>build</code> folder as explained above.</p>"},{"location":"getting-started/assembling-the-board/","title":"Assembling the Board","text":""},{"location":"getting-started/assembling-the-board/#soldering-components","title":"Soldering components","text":""},{"location":"getting-started/assembling-the-board/#flashing-the-rom","title":"Flashing the ROM","text":"<p>Before powering up your ByteCradle board for the first time, it is essential to flash the appropriate ROM image onto the onboard memory chip. The required ROM chip and image depend on the variant of the board:</p> <ul> <li>ByteCradle Tiny: Uses an SST39SF010 (1 Mbit) chip.</li> <li>ByteCradle Mini: Uses an SST39SF040 (4 Mbit) chip.</li> </ul> <p>Each board requires a specific ROM file that matches its hardware configuration.</p>"},{"location":"getting-started/assembling-the-board/#required-tools","title":"Required Tools","text":"<p>To flash the ROM, you'll need a compatible EPROM/Flash programmer. Options include:</p> <ul> <li>Commercial Programmers:<ul> <li>TL866II Plus: A popular, affordable universal programmer.</li> <li>XGecu T48: A more advanced model supporting a wide range of devices.</li> </ul> </li> <li>Open Source and DIY Alternatives:<ul> <li>Pico-SST39SF0x0 Programmer: A lightweight and affordable programmer using a Raspberry Pi Pico.</li> <li>Arduino-based Flashers: Utilize an Arduino (e.g., Uno) with community firmware for programming simple parallel flash devices.</li> </ul> </li> </ul> <p>Choosing a Flasher</p> <p>Commercial programmers offer ready-to-use software and broad device support. However, open-source solutions like the Pico-SST39SF0x0 Programmer are cost-effective and excellent for DIY enthusiasts.</p>"},{"location":"getting-started/assembling-the-board/#flashing-process-overview","title":"Flashing Process Overview","text":"<ol> <li> <p>Set Up the Programmer:</p> <ul> <li>For the Pico-SST39SF0x0 Programmer:</li> <li>Flash your Raspberry Pi Pico with the firmware from the GitHub repository.</li> <li>Connect the ROM chip to the Pico according to the wiring guide provided in the repository.</li> </ul> </li> <li> <p>Load the ROM File:</p> <ul> <li>Open your flashing software.</li> <li>Select the correct chip type from the supported devices list.</li> <li>Load the appropriate ROM image for your ByteCradle board variant.</li> </ul> </li> <li> <p>Write and Verify:</p> <ul> <li>Erase the chip if necessary (some programmers do this automatically).</li> <li>Write the ROM file to the flash chip.</li> <li>Perform a verification pass to confirm the write was successful.</li> </ul> </li> <li> <p>Install the ROM:</p> <ul> <li>After successful flashing, insert the ROM chip carefully into its socket, ensuring correct orientation.</li> </ul> </li> </ol> <p>Once the ROM is programmed and installed, you're ready to proceed with the first power-up!</p>"},{"location":"getting-started/first-power-up/","title":"First Power-Up and Testing","text":""},{"location":"getting-started/first-power-up/#hooking-up-the-power-supply","title":"Hooking up the Power Supply","text":"<p>The ByteCradle board requires a 5V power supply capable of delivering at least 500 mA of current. Power is supplied through a USB-B connector. The ByteCradle does not have any on-board power regulation. It is critical to use a reliable and regulated 5V power source to avoid damaging the board. Recommended options include:</p> <ul> <li>A direct connection to a computer USB port</li> <li>A certified USB wall adapter rated for 5V output</li> </ul> <p>Power Supply Safety</p> <p>Avoid using low-quality or unregulated power adapters, as unstable voltages can cause erratic behavior or permanent damage to the board.</p> <p>Power-Up Sequence</p> <p>Before powering up the board, make sure the serial communication cable (see next section) is connected and a serial port has been opened on your computer. This ensures you will see the header information that the board outputs upon boot. If you power on the board before setting up the serial connection, you can still communicate with it, but you will miss the initial startup messages. In that case, simply press the reset button on the board to perform a cold boot and re-trigger the startup sequence.</p>"},{"location":"getting-started/first-power-up/#setting-up-serial-communication","title":"Setting Up Serial Communication","text":"<p>Communication with the ByteCradle platform is handled via a standard RS232 serial interface, implemented using the onboard 65C51 ACIA (Asynchronous Communications Interface Adapter) and a MAX232 line driver. This setup ensures reliable and straightforward serial communication, supporting both TTL and RS232 voltage levels.</p> <p>The default communication settings are:</p> <ul> <li>Baud Rate: 115200</li> <li>Data Bits: 8</li> <li>Parity: None</li> <li>Stop Bits: 1</li> </ul> <p>(commonly referred to as 8N1 configuration).</p> <p>Several tools are available to interface with the board over RS232:</p> <ul> <li>Windows: PuTTY, Tera   Term</li> <li>MacOS: CoolTerm, or the built-in   <code>screen</code> command</li> <li>Linux: Minicom, <code>screen</code>, or   picocom</li> </ul> <p>Finding the correct serial port</p> <ul> <li>On Windows: Open Device   Manager and look under Ports (COM &amp; LPT). Your device will appear as   something like <code>COM3</code>, <code>COM4</code>, etc. </li> <li>On MacOS: Use the command <code>ls /dev/tty.*</code> in Terminal. Look for entries like <code>/dev/tty.usbserial-XXXXX</code>. </li> <li>On Linux: Use <code>ls /dev/ttyUSB*</code> or <code>ls /dev/ttyACM*</code> depending on your   USB-to-serial adapter. Common examples include <code>/dev/ttyUSB0</code>.</li> </ul> <p>Connection Tip</p> <p>After identifying the correct port, configure your terminal program with the settings above and open the connection. Upon powering up the ByteCradle, you should see output from the board if the connection is established correctly.</p>"},{"location":"getting-started/required-tools/","title":"Required Tools","text":"<p>The tools you'll need depend on whether you're assembling the board yourself or working with a pre-assembled unit.</p>"},{"location":"getting-started/required-tools/#for-manual-assembly","title":"For Manual Assembly","text":"<p>If you're starting from a bare PCB and sourcing your own components, ensure you have the following tools and equipment:</p> <ul> <li>Soldering iron \u2014 Preferably temperature-controlled for best results.</li> <li>Solder \u2014 Leaded solder is typically easier to work with, but choose   according to your preference or safety requirements.</li> <li>ROM flasher \u2014 A reliable, advanced commercial flasher such as the XGecu   PRO, which supports programming Atmel SST39SF0X0 series chips.</li> </ul>"},{"location":"getting-started/required-tools/#board-specific-requirements","title":"Board-Specific Requirements","text":"<ul> <li>For  TINY boards: A flasher that supports programming ATF22V10 chips.</li> <li>For  MINI boards: A flasher compatible with ATF1502AS chips.</li> </ul>"},{"location":"getting-started/required-tools/#for-pre-assembled-boards","title":"For Pre-Assembled Boards","text":"<p>If you're using a board that has already been assembled, your tool requirements are simpler:</p> <ul> <li>A SST39SF0X0-compatible flasher \u2014 Many affordable and widely available   flashers support this chip family.</li> </ul> <p>Tip</p> <p>While high-end flashers like the XGecu PRO are recommended for reliability, budget-friendly options may suffice for casual use, especially with pre-assembled boards. A budget-friendly option is the PICO-SST39SF0x0-programmer.</p>"},{"location":"hardware/board-overview/","title":"Board Overview","text":""},{"location":"hardware/board-overview/#tier-system-overview","title":"Tier System Overview","text":"<p>ByteCradle\u2019s hardware platform is designed with flexibility and accessibility in mind, offering a scalable ecosystem for retro computing enthusiasts, embedded developers, and educational environments. It features a tiered architecture to accommodate both minimalistic setups and more capable systems, ensuring a smooth learning curve while supporting increasingly complex applications. Each tier is carefully engineered to balance performance, expandability, and simplicity, making it easy to dive into 65xx-based system design, from first experiments to advanced custom builds.</p>"},{"location":"hardware/board-overview/#tiny-sbc","title":"Tiny SBC","text":"<ul> <li>Simplified design with a small footprint.</li> <li>Memory: 32 KiB RAM and 32 KiB ROM.</li> <li>Programmable logic: Utilizes small PLDs to minimize discrete components.</li> <li>Ideal for learning, experimentation, and small embedded projects.</li> </ul> <p>\ud83d\udd0d View schematic</p>"},{"location":"hardware/board-overview/#mini-sbc","title":"Mini SBC","text":"<ul> <li>Advanced design with bank switching for greater memory capabilities.</li> <li>Memory: 512 KiB of RAM and 512 KiB of ROM (bank-switched).</li> <li>Programmable logic: Built around CPLDs for greater integration.</li> <li>Includes a 65C22 VIA to interface with an SD card for persistent   storage and potential peripheral expansion.</li> <li>Perfect for exploring larger applications, file systems, and   system-level programming.</li> </ul> <p>\ud83d\udd0d View schematic</p>"},{"location":"hardware/board-overview/#feature-comparison","title":"Feature Comparison","text":"Feature Tiny SBC Mini SBC Frequency 16 MHz 12 MHz RAM 32 KiB 512 KiB (bank switched) ROM 32 KiB 512 KiB (bank switched) Bank Switching \u274c \u2705 (64 \u00d7 8 KiB banks) SD Card Support \u274c \u2705 (via 65C22 VIA) Serial Interface 65C51 ACIA 65C51 ACIA I/O mapping ATF22V10 ATF1502 Expansion Options Exposes system bus Exposes system bus and VIA bus"},{"location":"hardware/board-overview/#programmable-logic","title":"Programmable logic","text":"<p>Both ByteCradle boards use programmable logic devices, a ATF22V10 PLD in the  TINY board and a ATF1502 CPLD for the  MINI board. These chips handle essential control logic like address decoding, chip selects, and bank switching. These devices replace traditional discrete logic chips (such as 74-series TTL), resulting in faster, more compact, and more reliable designs.</p>"},{"location":"hardware/board-overview/#tiny-board-atf22v10","title":"Tiny Board - ATF22V10","text":"<p>The  TINY Board uses an ATF22V10 PLD to implement address decoding and I/O mapping for RAM, ROM, and the ACIA serial interface. This chip allows tight integration of logic without chaining multiple discrete components, which reduces propagation delays. Its internal logic can respond in under 10\u202fns, enabling the system to run stably at 16\u202fMHz\u2014much faster than typical retro systems.</p>"},{"location":"hardware/board-overview/#mini-board-atf1502","title":"Mini Board - ATF1502","text":"<p>The  MINI Board uses an ATF1502 CPLD, which offers significantly more logic resources. It handles complex tasks like dynamic RAM and ROM bank switching, peripheral selection, and reading/writing to the bank registers. Updates can be made through JTAG without changing hardware. The CPLD's deterministic timing is critical for maintaining stability at 12\u202fMHz.</p>"},{"location":"hardware/memory-maps/","title":"Memory Maps","text":""},{"location":"hardware/memory-maps/#tiny-board","title":"Tiny Board","text":"<p>The Tiny Board uses a flat 64 KiB memory map typical of 65C02-based systems. The first 256 bytes (<code>$0000\u2013$00FF</code>) are Zero Page RAM, followed by the stack at <code>$0100\u2013$01FF</code>. The range <code>$0200\u2013$03FF</code> is reserved for OS use, while <code>$0400\u2013$7EFF</code> serves as general-purpose RAM.</p> <p>A small I/O region at <code>$7F00\u2013$7FFF</code> includes only <code>$7F04\u2013$7F07</code>, which is connected to a 65C51 ACIA UART for serial communication. The remainder of the I/O space is currently unused but mapped to RAM, meaning it is technically accessible for reads and writes. However, using this area is not recommended, as future hardware revisions may repurpose it. Users may also reconfigure the address decoding logic by updating the ATF22V10 chip to change or expand the I/O mapping as needed.</p> <p>The upper 32 KiB (<code>$8000\u2013$FFFF</code>) is mapped to ROM, containing system firmware such as a monitor or BASIC interpreter.</p> Address Range Size Description <code>$0000-$00FF</code> 256 bytes Zero Page RAM <code>$0100-$01FF</code> 256 bytes Stack <code>$0200-$03FF</code> 512 bytes Reserved (OS Use) <code>$0400-$7EFF</code> ~31 KiB General Purpose RAM <code>$7F00-$7F03</code> 4 bytes Unused / Reserved <code>$7F04-$7F07</code> 4 bytes ACIA (UART) <code>$7F08-$7FFF</code> 248 bytes Unused / Reserved <code>$8000-$FFFF</code> 32 KiB ROM"},{"location":"hardware/memory-maps/#mini-board","title":"Mini Board","text":"<p>The Mini Board features a flexible 64 KiB memory map designed to support both fixed and bank-switched memory regions. The lower memory (<code>$0000\u2013$7EFF</code>) is primarily RAM, with the first 256 bytes (<code>$0000\u2013$00FF</code>) allocated as Zero Page, and the next 256 bytes (<code>$0100\u2013$01FF</code>) serving as the stack. Addresses <code>$0200\u2013$07FF</code> are reserved for OS-level functionality, while the remainder up to <code>$7EFF</code> is available as general-purpose RAM, implemented across fixed banks 0\u20133.</p> <p>The region <code>$7F00\u2013$7FFF</code> is dedicated to memory-mapped I/O, divided into four 64-byte blocks using only address lines A6 and A7. The first block (<code>$7F00\u2013$7F3F</code>) connects to a 65C51 ACIA for serial communication, while the second (<code>$7F40\u2013$7F7F</code>) maps to a 6522 VIA. The remaining two blocks (<code>$7F80\u2013$7FBF</code> and <code>$7FC0\u2013$7FFF</code>) are used to write to the ROM and RAM bank registers, respectively.</p> <p>The upper half of the address space is split between banked and fixed ROM/RAM. The ranges <code>$8000\u2013$9FFF</code> and <code>$A000\u2013$BFFF</code> are bank-switched RAM and ROM windows, supporting 64 banks each. The final 16 KiB (<code>$C000\u2013$FFFF</code>) is mapped to fixed ROM, permanently connected to banks 0 and 1, containing  critical system firmware.</p> <p>Warning</p> <p>The bank-switched ROM and RAM regions (<code>$A000\u2013$BFFF</code> and <code>$8000\u2013$9FFF</code>) share the same physical memory space as the fixed ROM (<code>$C000\u2013$FFFF</code>) and fixed RAM (<code>$0000\u2013$7EFF</code>), respectively. This means that selecting ROM banks 0\u20131 or RAM banks 0\u20133 will expose the same physical memory already mapped in the fixed regions. For example, if RAM bank 0 is selected, writes may unintentionally modify the stack or zero page; selecting ROM bank 0 might interfere with the interrupt vectors or firmware routines.  </p> <p>While overlapping ROM banks are less problematic\u2014since ROM is typically read-only and cannot be written to\u2014it can still cause confusion or redundancy if the same code or data appears in both fixed and banked areas. It is strongly recommended to begin using RAM banks from 4 upwards and ROM banks from 2 upwards to avoid overlapping with fixed memory areas and ensure predictable behavior.</p> Address Range Size Description <code>$0000-$00FF</code> 256 bytes Zero Page RAM <code>$0100-$01FF</code> 256 bytes Stack <code>$0200-$07FF</code> 512 bytes Reserved (used by BCOS) <code>$0800-$7EFF</code> 30 KiB General Purpose RAM (Fixed, Banks 0\u20133) <code>$7F00-$7F3F</code> 64 bytes ACIA (UART) <code>$7F40-$7F7F</code> 64 bytes VIA <code>$7F80-$7FBF</code> 64 bytes ROM Bank Register <code>$7FC0-$7FFF</code> 64 bytes RAM Bank Register <code>$8000-$9FFF</code> 8 KiB Bank-switched RAM Window (Banks 0\u201363) <code>$A000-$BFFF</code> 8 KiB Bank-switched ROM Window (Banks 0\u201363) <code>$C000-$FFFF</code> 16 KiB Fixed ROM (Banks 0\u20131 mapped permanently)"},{"location":"hardware/schematics-layout/","title":"Board Schematics","text":"<p>The schematics for the <code>TINY</code> and <code>MINI</code> boards are provided in SVG format, which allows for infinite scaling without any loss of detail. This makes them ideal for inspection, printing, or embedding in other documents. Simply click on any image to view it full-size in your browser or download it directly for offline use.</p>"},{"location":"hardware/schematics-layout/#tiny","title":"Tiny","text":""},{"location":"hardware/schematics-layout/#mini","title":"Mini","text":""},{"location":"introduction/what-is-platform/","title":"Introducing the ByteCradle 6502 Platform","text":"<p>In the 1970s, the future of personal computing was 8-bit. Microcomputers and home computers of the era almost universally began with 8-bit processors. The legacy of this era still shapes computing today \u2014 the prominence of the byte as a standard unit of storage and data is a direct inheritance from these early systems.</p> <p>The ByteCradle 6502 embraces this legacy. It is a hands-on, 8-bit computing platform built around the WDC 65C02 microprocessor, a modern variant of the classic MOS 6502. Designed for hobbyists, educators, and retrocomputing enthusiasts, the ByteCradle 6502 offers a practical gateway into low-level system design, assembly programming, and hardware experimentation \u2014 all in the spirit of the early home computer revolution.</p>"},{"location":"introduction/what-is-platform/#tier-system-overview","title":"Tier System Overview","text":"<p>The platform is structured into two distinct tiers, each designed to balance functionality and cost. Lower tiers offer more affordable options, but with reduced feature sets compared to higher tiers.</p>"},{"location":"introduction/what-is-platform/#tiny-sbc","title":"Tiny SBC","text":"<ul> <li>65C02 processor running at 16 MHz</li> <li>Simplified design with a small footprint.</li> <li>Memory: 32 KiB RAM and 32 KiB ROM.</li> <li>I/O communication via a 65C51 ACIA.</li> <li>Programmable logic: Utilizes small PLDs to minimize discrete components.</li> <li>Ideal for learning, experimentation, and small embedded projects.</li> </ul>"},{"location":"introduction/what-is-platform/#mini-sbc","title":"Mini SBC","text":"<ul> <li>65C02 processor running at 8 MHz</li> <li>Advanced design with bank switching for greater memory capabilities.</li> <li>Memory: 512 KiB of RAM and 512 KiB of ROM (bank-switched).</li> <li>I/O communication via a 65C51 ACIA.</li> <li>Programmable logic: Built around CPLDs for greater integration.</li> <li>Includes a 65C22 VIA to interface with an SD card for persistent   storage and potential peripheral expansion.</li> <li>Perfect for exploring larger applications, file systems, and   system-level programming.</li> </ul>"},{"location":"introduction/why-65c02/","title":"Why the 65C02?","text":""},{"location":"introduction/why-65c02/#choosing-the-right-cpu","title":"Choosing the Right CPU","text":"<p>At the outset of this project, one of the most critical decisions was selecting a CPU architecture. Several classic 8-bit and 16-bit processors were considered \u2014 notably the MOS 6502, Zilog Z80, and Intel 8088/8086.</p> <p>Each of these CPUs played a foundational role in early personal computing. However, important practical considerations shaped the final choice:</p> <ul> <li>The 8088/8086, though historically significant, is no longer in   production.</li> <li>The Z80, another strong contender, also recently ceased production \u2014   though both it and the 8086 remain available through surplus and legacy   channels.</li> <li>The WDC 65C02, a modern CMOS variant of the original 6502, is still in   active production. It not only has robust commercial support but also   carries the legacy of influential systems like the Apple II, Commodore   64, BBC Micro, and NES.</li> </ul> <p>This combination of availability, legacy, and technical elegance made the 65C02 a natural choice.</p>"},{"location":"introduction/why-65c02/#instruction-set-simplicity","title":"Instruction Set Simplicity","text":"<p>One of the most compelling arguments in favor of the 6502 \u2014 especially for a learning-oriented platform \u2014 is its simplicity. Its architecture and instruction set are compact and easy to grasp, making it particularly approachable for those new to assembly language or low-level system design.</p> <p>Here's a comparative look at instruction set sizes:</p> CPU Approximate Number of Instructions Notes 6502 ~56 Small, minimal instruction set; easy to memorize 65C02 ~70 Enhanced 6502 with additional instructions and fixed quirks 65C816 ~92 16-bit extension of 65C02; backward-compatible, adds new registers 8080 ~78 Slightly more complex, more registers than 6502 Z80 ~158 Includes extended opcodes, prefixes, and register pairs 8086/88 ~133 16-bit instructions, multi-byte ops, complex syntax and segments <p>Note</p> <p>Instruction counts are approximate because architectures differ in how they handle prefixes, variants, addressing modes, and unofficial or undocumented opcodes. Extended CPUs (like Z80 or 65C816) often reuse base instructions with added functionality.</p> <p>While instruction count isn't the sole measure of complexity, it does reflect how minimal and focused the 6502 is. In contrast, the 8080 and Z80 offer richer feature sets that can also present steeper learning curves.</p> <p>Subjectivity note</p> <p>The ease of programming in assembly is naturally a matter of opinion. However, there is broad consensus that the 6502 is beginner-friendly, largely due to its straightforward instruction set and predictable behavior.</p> <p>By building this platform around the 6502, we aim to blend historical relevance with practical accessibility, offering a compelling environment for both exploration and education in low-level computing.</p>"},{"location":"software/kernel-functions/","title":"Kernel functions","text":"<p>The system exposes a set of core kernel functions at fixed memory addresses located just below the 6502 vector table. This area is referred to as the jump table.</p> <p>Each jump table entry is a 3-byte <code>JMP</code> instruction that redirects to the actual implementation of a function. This design allows system programs and user applications to call kernel routines via stable, absolute addresses, regardless of where the underlying code is actually located.</p>"},{"location":"software/kernel-functions/#how-it-works","title":"How It Works","text":"<p>The jump table starts at address <code>$FFE5</code>, with each function occupying 3 bytes (the size of a <code>JMP</code> absolute instruction). For example:</p> <pre><code>jsr $FFE5  ; call putstr\n</code></pre> <p>This instruction jumps to the putstr routine, allowing the user to print a string without needing to know where putstr is implemented in memory. This makes the jump table a forward-compatible interface to the kernel.</p>"},{"location":"software/kernel-functions/#overview-jump-table","title":"Overview jump table","text":"<p>Below is an overview of currently available jump table entries:</p> Label Address Description Input Registers Garbled Registers <code>putstr</code> <code>$FFE5</code> Prints a null-terminated string. <code>X:A</code> = High:Low pointer to string <code>A</code>, <code>X</code>, <code>Y</code> <code>putstrnl</code> <code>$FFE8</code> Prints a null-terminated string followed by a CRLF. <code>X:A</code> = High:Low pointer to string <code>A</code>, <code>X</code>, <code>Y</code> <code>putch</code> <code>$FFEB</code> Outputs a single character to ACIA. <code>A</code> = Character None <code>newline</code> <code>$FFEE</code> Prints carriage return and line feed. - None <code>puthex</code> <code>$FFF1</code> Prints a byte in hexadecimal format. <code>A</code> = Byte to print None <code>putdec</code> <code>$FFF4</code> Prints a byte in decimal format. <code>A</code> = Byte to print <code>X</code>, <code>Y</code> <code>getch</code> <code>$FFF7</code> Retrieves a character from input buffer. \u2014 <code>A</code> <p>Note</p> <p>The jump table is exactly the same for both the  TINY and  MINI boards.</p> <p>Warning</p> <p>Garbled refers to CPU registers whose contents are modified or overwritten by a routine and are not restored before returning. This means the calling code should not rely on the original values of these registers after the routine executes.</p> <p>For example, if a function garbles register <code>X</code>, then any value that was in  <code>X</code> before the function call may be lost and should not be assumed valid  afterward. To preserve important register values across such calls, the  caller is responsible for saving and restoring them (e.g., using <code>PHA</code>,  <code>PHX</code>, <code>PHY</code> and their corresponding pull instructions).</p>"},{"location":"software/operating-system/","title":"Operating Systems","text":"<p>This page describes two minimalist operating systems: TINYROM, a ROM-based OS for the TINY board featuring a menu-driven interface without disk storage, and BCOS, a lightweight disk operating system for the MINI board providing basic file management and serial communication using familiar Linux-style commands.</p>"},{"location":"software/operating-system/#tinyrom-operating-system-tiny-board","title":"TINYROM operating system (TINY board)","text":""},{"location":"software/operating-system/#overview","title":"Overview","text":"<p>TINYROM is a minimalist ROM-based operating system and runtime environment for the  TINY board. It is designed to be as small and simple as possible, offering a bare-metal interface that boots directly into a menu-driven selector for launching built-in programs, test routines, and games \u2014 all stored within a compact 32 KiB ROM image.</p> <p>Unlike more complex operating systems that manage filesystems or dynamic storage (see below), TINYROM does not interface with disks or SD cards. Instead, it provides a tiny kernel consisting solely of  low-level I/O routines for communicating with the 65C51 ACIA serial interface. These routines allow basic input and output over a serial terminal and form the foundation for user interaction and debugging.</p> <p>Upon startup, TINYROM presents a static selection menu through the serial interface, enabling users to choose from a set of preloaded software \u2014 typically small utilities, diagnostics, or simple games.</p>"},{"location":"software/operating-system/#bytecradle-operating-system-mini-board","title":"ByteCradle Operating System (MINI board)","text":""},{"location":"software/operating-system/#overview_1","title":"Overview","text":"<p>The  MINI board runs on BCOS (ByteCradle Operating System), a minimalist, single-user disk operating system (SUDOS) purpose-built for the MINI. Designed with clarity, compactness, and practical utility in mind, BCOS offers essential functionality for persistent storage access and serial communication, without the complexity of multitasking or modern OS abstractions.</p> <p>At its core, BCOS presents a simple, navigable view of the SD card\u2019s contents, supporting basic file operations such as directory listing, file reading, writing, and \u2014 critically \u2014 the ability to load and execute binary programs directly from the SD card. This capability allows BCOS to serve as a lightweight but extensible platform for launching standalone applications with minimal runtime overhead.</p> <p>In addition to its command-line shell, BCOS exposes a set of  low-level I/O routines for working with the  65C51 ACIA serial interface. These include functions for reading characters, writing characters, and outputting entire strings over the serial port, enabling user programs to easily perform serial communication without reimplementing low-level logic.</p> <p>Communication via the 65C51 ACIA serves both as the user console and as a fundamental I/O channel, making BCOS suitable for both interactive and automated tasks on constrained 8-bit hardware.</p>"},{"location":"software/operating-system/#navigation","title":"Navigation","text":"<p>BCOS leverages common Linux-style commands for file and directory management, offering a familiar environment to users accustomed to Linux or UNIX systems. Below are examples of frequently used commands:</p> <ul> <li> <p>List directory contents (<code>ls</code>): To view the files and directories within   the current directory, simply type:   <pre><code>ls\n</code></pre></p> </li> <li> <p>Change directory (<code>cd</code>): To navigate to another directory, use:   <pre><code>cd dirname\n</code></pre>   For example, to move up one directory level:   <pre><code>cd ..\n</code></pre></p> </li> <li> <p>Executing programs: Executable files typically have a <code>.COM</code> extension. To   run these files, type their base name (without the <code>.COM</code> extension). For   instance, to execute a program named <code>MYAPP.COM</code>, simply type:   <pre><code>myapp\n</code></pre></p> </li> </ul> <p>Note</p> <p>While BCOS internally manages file names in uppercase, users may conveniently enter commands and file names in lowercase.</p>"},{"location":"software/software-overview/","title":"Software Overview","text":"\u2728 Operating System <p>Understand how the operating system manages tasks and interacts with the hardware.</p> \ud83d\udd27 Kernel Functions <p>Explore kernel-level functions that handle modularized input/output operations.</p>"},{"location":"tutorials/debugging/","title":"Debugging","text":""},{"location":"tutorials/inline-assembler/","title":"Inline Assembler Tutorial","text":"<p>This section begins with a brief overview of the monitor and its role in the system, followed by a tutorial on how to use its inline assembler feature to build small, custom code snippets.</p>"},{"location":"tutorials/inline-assembler/#monitor","title":"Monitor","text":"<p>The monitor is a simple interactive program that gives you low-level control over the system\u2019s memory and CPU. It supports reading and writing memory, executing code at arbitrary addresses, disassembling machine instructions, and assembling new instructions directly from the command line using its built-in assembler.</p> <p>Note</p> <p>The description provided here pertains to the <code>/TINY/</code> board, but the instructions are transferable to the <code>/MINI/</code> board. The major difference is that the <code>/MINI/</code> board supports bank switching and has its ROM starting at <code>0xC000</code> where as the <code>/TINY/</code> has ROM starting at <code>0x8000</code>.</p> <p>Upon booting the <code>/TINY/</code> board, you will be greeted with a selection menu which allows you to select the <code>MONITOR</code> option. </p> <pre><code>+----------------------------------------------+\n|             BYTECRADLE MONITOR               |\n+----------------------------------------------+\n| FREE ZERO PAGE :     0x40 - 0xFF             |\n| FREE RAM       : 0x0400 - 0x7F00             |\n| ROM            : 0x8000 - 0xFFFF             |\n+----------------------------------------------+\n| COMMANDS                                     |\n| R&lt;XXXX&gt;[:&lt;XXXX&gt;] read memory                 |\n| W&lt;XXXX&gt;          write to memory             |\n| G&lt;XXXX&gt;          run from address            |\n| A&lt;XXXX&gt;          assemble from address       |\n| D&lt;XXXX&gt;          disassemble from address    |\n| M                show this menu              |\n| Q                quit                        |\n+----------------------------------------------+\n</code></pre>"},{"location":"tutorials/inline-assembler/#monitor-functions","title":"Monitor Functions","text":"<p>The Monitor provides several commands that allow direct interaction with the system's memory and CPU. These functions are essential for writing, testing, and debugging programs at a low level:</p> <ul> <li>Reading memory (<code>R&lt;XXXX&gt;[:&lt;XXXX&gt;]</code>) Allows you to examine memory contents at a   specific address or within a range of addresses.</li> <li>Writing to memory (<code>W&lt;XXXX&gt;</code>) Enables manual modification of memory contents at   a given address. Useful for inserting data like ASCII strings or instructions.</li> <li>Running code (<code>G&lt;XXXX&gt;</code>) Starts execution of code from a specific memory   address, enabling you to run programs you have written or loaded into RAM.</li> <li>Inline assembly (<code>A&lt;XXXX&gt;</code>) Opens an assembler interface at the specified   address, allowing you to input machine code instructions directly in mnemonic   form.</li> <li>Disassembling code (<code>D&lt;XXXX&gt;</code>) Reads machine code from memory and converts it   back into human-readable assembly instructions.</li> <li>Showing the menu (<code>M</code>) Displays the monitor\u2019s command menu and current memory   layout for quick reference.</li> <li>Quitting (<code>Q</code>) Exits the monitor and returns control to the system selection   menu or operating environment.</li> </ul> <p>These functions work together to provide a lightweight but powerful development environment directly on the hardware.</p>"},{"location":"tutorials/inline-assembler/#sample-programs","title":"Sample programs","text":"<p>The following examples demonstrate how to use the Monitor\u2019s inline assembler, memory writing, and program execution features. By manually assembling instructions and inserting data, you can create simple programs directly in memory and run them without needing external tools. These exercises are ideal for learning how the system interacts with memory and the CPU at a low level.</p>"},{"location":"tutorials/inline-assembler/#hello-world","title":"Hello World","text":"<p>Open the inline-assembler using <code>A0400</code> and insert the following assembly instructions:</p> <pre><code>0400: LDA #10       A9 10\n0402: LDX #04       A2 04\n0404: JSR FFE8      20 E8 FF\n0407: RTS           60\n</code></pre> <p>Next, insert the ASCII characters for the string <code>Hello World!</code> by first typing <code>W0410</code> and entering the following values:</p> <pre><code>0410: 48 65 6C 6C 6F 20 57 6F 72 6C 64 21 00\n</code></pre> <p>To run the small program, type <code>G0400</code>.</p> <p>The expected output is:</p> <pre><code>@:G0400\nHello World!\n</code></pre> <p>Note</p> <p>Observe that we used one of the kernel functions, <code>putch</code> located at <code>#FFE8</code> to output a single character to the ACIA. An overview of all the kernel functions can be found here.</p>"},{"location":"tutorials/inline-assembler/#fibonacci-series","title":"Fibonacci series","text":"<p>Open the inline-assembler using <code>A0400</code> and insert the following assembly instructions:</p> <pre><code>0400: LDA #01                  A9 01\n0402: LDX #01                  A2 01\n0404: LDY #00                  A0 00\n0406: PHX                      DA\n0407: PHY                      5A\n0408: JSR FFF4                 20 F4 FF\n040B: JSR FFEE                 20 EE FF\n040E: PLY                      7A\n040F: PLX                      FA\n0410: STX 40                   86 40\n0412: CLC                      18\n0413: PHA                      48\n0414: ADC 40                   65 40\n0416: PLX                      FA\n0417: INY                      C8\n0418: CPY #0C                  C0 0C\n041A: BNE EA                   D0 EA\n041C: RTS                      60\n</code></pre> <p>Note</p> <p>The value of <code>$40</code> used for <code>STX 40</code> and <code>ADC 40</code> refer to zero page address <code>$40</code>. Note that we are only allowed to use zero page addresses starting from <code>$40</code> as everything below is used by the system (including the monitor).</p> <p>To run the program, type <code>G0400</code>, which yields the following output:</p> <pre><code>@:G0400\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n</code></pre>"},{"location":"tutorials/peripherals/","title":"Working with peripherals","text":""}]}