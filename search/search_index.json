{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ByteCradle 6502 Documentation","text":"<p>The ByteCradle 6502 is a single-board computer (SBC) platform built around the WDC 65C02 microprocessor.   It is designed for learning and experimenting with simple operating systems on 8-bit hardware. Whether you are new to 8-bit computers or an experienced hardware tinkerer, ByteCradle offers an accessible and expandable environment to explore these topics.</p>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"\ud83d\ude80 Getting Started <p>Learn how to assemble the board, power up safely, and run your first program.</p> \ud83d\udda5\ufe0f Hardware Overview <p>Dive deep into the hardware design, schematics, and engineering decisions behind ByteCradle.</p> \ud83d\uddb1\ufe0f Software Emulator <p>Install and use the emulator to prototype, test, and debug your 65C02 programs.</p> \ud83d\udca1 Tutorials <p>Start coding! Follow step-by-step guides for writing assembly, peripherals control, and debugging.</p> \u2699\ufe0f Advanced Topics <p>Explore system expansion, hardware mods, and building more sophisticated applications.</p>"},{"location":"getting-started/assembling-the-board/","title":"Assembling the Board","text":""},{"location":"getting-started/assembling-the-board/#flashing-the-rom","title":"Flashing the ROM","text":"<p>Before powering up your ByteCradle board for the first time, it's essential to flash the appropriate ROM image onto the onboard memory chip. The required ROM chip and image depend on the variant of the board:</p> <ul> <li>ByteCradle Tiny: Uses an SST39SF010 (1 Mbit) chip.</li> <li>ByteCradle Mini: Uses an SST39SF040 (4 Mbit) chip.</li> </ul> <p>Each board requires a specific ROM file that matches its hardware configuration.</p>"},{"location":"getting-started/assembling-the-board/#required-tools","title":"Required Tools","text":"<p>To flash the ROM, you'll need a compatible EPROM/Flash programmer. Options include:</p> <ul> <li>Commercial Programmers:<ul> <li>TL866II Plus: A popular, affordable universal programmer.</li> <li>XGecu T48: A more advanced model supporting a wide range of devices.</li> </ul> </li> <li>Open Source and DIY Alternatives:<ul> <li>Pico-SST39SF0x0 Programmer: A lightweight and affordable programmer using a Raspberry Pi Pico.</li> <li>Arduino-based Flashers: Utilize an Arduino (e.g., Uno) with community firmware for programming simple parallel flash devices.</li> </ul> </li> </ul> <p>Choosing a Flasher</p> <p>Commercial programmers offer ready-to-use software and broad device support. However, open-source solutions like the Pico-SST39SF0x0 Programmer are cost-effective and excellent for DIY enthusiasts.</p>"},{"location":"getting-started/assembling-the-board/#flashing-process-overview","title":"Flashing Process Overview","text":"<ol> <li> <p>Set Up the Programmer:</p> <ul> <li>For the Pico-SST39SF0x0 Programmer:</li> <li>Flash your Raspberry Pi Pico with the firmware from the GitHub repository.</li> <li>Connect the ROM chip to the Pico according to the wiring guide provided in the repository.</li> </ul> </li> <li> <p>Load the ROM File:</p> <ul> <li>Open your flashing software.</li> <li>Select the correct chip type from the supported devices list.</li> <li>Load the appropriate ROM image for your ByteCradle board variant.</li> </ul> </li> <li> <p>Write and Verify:</p> <ul> <li>Erase the chip if necessary (some programmers do this automatically).</li> <li>Write the ROM file to the flash chip.</li> <li>Perform a verification pass to confirm the write was successful.</li> </ul> </li> <li> <p>Install the ROM:</p> <ul> <li>After successful flashing, insert the ROM chip carefully into its socket, ensuring correct orientation.</li> </ul> </li> </ol> <p>Once the ROM is programmed and installed, you're ready to proceed with the first power-up!</p>"},{"location":"getting-started/first-power-up/","title":"First Power-Up and Testing","text":""},{"location":"getting-started/first-power-up/#hooking-up-the-power-supply","title":"Hooking up the Power Supply","text":"<p>The ByteCradle board requires a 5V power supply capable of delivering at least 500 mA of current. Power is supplied through a USB-B connector. The ByteCradle does not have any on-board power regulation. It is critical to use a reliable and regulated 5V power source to avoid damaging the board. Recommended options include:</p> <ul> <li>A direct connection to a computer USB port</li> <li>A certified USB wall adapter rated for 5V output</li> </ul> <p>Power Supply Safety</p> <p>Avoid using low-quality or unregulated power adapters, as unstable voltages can cause erratic behavior or permanent damage to the board.</p> <p>Power-Up Sequence</p> <p>Before powering up the board, make sure the serial communication cable (see next section) is connected and a serial port has been opened on your computer. This ensures you will see the header information that the board outputs upon boot. If you power on the board before setting up the serial connection, you can still communicate with it, but you will miss the initial startup messages. In that case, simply press the reset button on the board to perform a cold boot and re-trigger the startup sequence.</p>"},{"location":"getting-started/first-power-up/#setting-up-serial-communication","title":"Setting Up Serial Communication","text":"<p>Communication with the ByteCradle platform is handled via a standard RS232 serial interface, implemented using the onboard 65C51 ACIA (Asynchronous Communications Interface Adapter) and a MAX232 line driver. This setup ensures reliable and straightforward serial communication, supporting both TTL and RS232 voltage levels.</p> <p>The default communication settings are:</p> <ul> <li>Baud Rate: 115200</li> <li>Data Bits: 8</li> <li>Parity: None</li> <li>Stop Bits: 1</li> </ul> <p>(commonly referred to as 8N1 configuration).</p> <p>Several tools are available to interface with the board over RS232:</p> <ul> <li>Windows: PuTTY, Tera   Term</li> <li>MacOS: CoolTerm, or the built-in   <code>screen</code> command</li> <li>Linux: Minicom, <code>screen</code>, or   picocom</li> </ul> <p>Finding the correct serial port</p> <ul> <li>On Windows: Open Device   Manager and look under Ports (COM &amp; LPT). Your device will appear as   something like <code>COM3</code>, <code>COM4</code>, etc. </li> <li>On MacOS: Use the command <code>ls /dev/tty.*</code> in Terminal. Look for entries like <code>/dev/tty.usbserial-XXXXX</code>. </li> <li>On Linux: Use <code>ls /dev/ttyUSB*</code> or <code>ls /dev/ttyACM*</code> depending on your   USB-to-serial adapter. Common examples include <code>/dev/ttyUSB0</code>.</li> </ul> <p>Connection Tip</p> <p>After identifying the correct port, configure your terminal program with the settings above and open the connection. Upon powering up the ByteCradle, you should see output from the board if the connection is established correctly.</p>"},{"location":"hardware/board-overview/","title":"Board Overview","text":""},{"location":"hardware/board-overview/#tier-system-overview","title":"Tier System Overview","text":"<p>The platform currently consists of two distinct tiers, each targeting different levels of complexity:</p>"},{"location":"hardware/board-overview/#tiny-sbc","title":"Tiny SBC","text":"<ul> <li>Simplified design with a small footprint.</li> <li>Memory: 32 KiB RAM and 32 KiB ROM.</li> <li>Programmable logic: Utilizes small PLDs to minimize discrete components.</li> <li>Ideal for learning, experimentation, and small embedded projects.</li> </ul>"},{"location":"hardware/board-overview/#mini-sbc","title":"Mini SBC","text":"<ul> <li>Advanced design with bank switching for greater memory capabilities.</li> <li>Memory: 512 KiB of RAM and 512 KiB of ROM (bank-switched).</li> <li>Programmable logic: Built around CPLDs for greater integration.</li> <li>Includes a 65C22 VIA to interface with an SD card for persistent   storage and potential peripheral expansion.</li> <li>Perfect for exploring larger applications, file systems, and   system-level programming.</li> </ul>"},{"location":"hardware/board-overview/#feature-comparison","title":"Feature Comparison","text":"Feature Tiny SBC Mini SBC RAM 32 KiB 512 KiB (bank switched) ROM 32 KiB 512 KiB (bank switched) Bank Switching \u274c \u2705 (64 \u00d7 8 KiB banks) SD Card Support \u274c \u2705 (via 65C22 VIA) I/O Interface 65C51 ACIA 65C51 ACIA Expansion Options Exposes system bus Exposes system bus and VIA bus"},{"location":"introduction/what-is-platform/","title":"Introducing the ByteCradle 6502 Platform","text":"<p>The ByteCradle 6502 is a hands-on, 8-bit computing platform built around the WDC 65C02 microprocessor. It is designed for hobbyists, educators, and retrocomputing enthusiasts who want to dive into low-level system design, assembly programming, and hardware experimentation.</p> <p>The platform intentionally keeps the chip count low, using programmable logic devices (PLDs) and complex programmable logic devices (CPLDs) to simplify circuitry while maintaining expandability and flexibility.</p>"},{"location":"introduction/what-is-platform/#tier-system-overview","title":"Tier System Overview","text":"<p>The platform currently consists of two distinct tiers, each targeting different levels of complexity:</p>"},{"location":"introduction/what-is-platform/#tiny-sbc","title":"Tiny SBC","text":"<ul> <li>Simplified design with a small footprint.</li> <li>Memory: 32 KiB RAM and 32 KiB ROM.</li> <li>Programmable logic: Utilizes small PLDs to minimize discrete components.</li> <li>Ideal for learning, experimentation, and small embedded projects.</li> </ul>"},{"location":"introduction/what-is-platform/#mini-sbc","title":"Mini SBC","text":"<ul> <li>Advanced design with bank switching for greater memory capabilities.</li> <li>Memory: 512 KiB of RAM and 512 KiB of ROM (bank-switched).</li> <li>Programmable logic: Built around CPLDs for greater integration.</li> <li>Includes a 65C22 VIA to interface with an SD card for persistent   storage and potential peripheral expansion.</li> <li>Perfect for exploring larger applications, file systems, and   system-level programming.</li> </ul>"},{"location":"introduction/why-65c02/","title":"Why the 65C02?","text":"<p>The choice of the WDC 65C02 as the core processor for the ByteCradle platform is deliberate and based on technical, historical, and practical considerations.</p>"},{"location":"introduction/why-65c02/#historical-significance","title":"Historical Significance","text":"<p>The 6502 microprocessor family has played a pivotal role in the history of computing. Introduced in 1975 by MOS Technology, the 6502 quickly became known for its simplicity, affordability, and effectiveness. It powered many influential computing systems of the late 1970s and 1980s, including:</p> <ul> <li>The Commodore 64</li> <li>The Apple II series</li> <li>The Atari 8-bit computers</li> <li>Early game consoles such as the Nintendo Entertainment System (via a 6502   derivative)</li> </ul> <p>The 6502 architecture became a foundation for both educational and commercial computing, introducing many engineers to low-level system design and programming. Choosing a 6502-based system connects users directly with these historical roots, providing a platform to understand the fundamental design principles that shaped modern computing.</p>"},{"location":"introduction/why-65c02/#ongoing-availability","title":"Ongoing Availability","text":"<p>Unlike many processors from the same era, the 65C02 is still in production today, manufactured by the Western Design Center (WDC). This continued availability ensures:</p> <ul> <li>Reliable sourcing from multiple vendors.</li> <li>Use of modern fabrication techniques, increasing consistency and reducing   power consumption.</li> <li>Long-term support for educational and experimental projects.</li> </ul> <p>This availability makes the 65C02 a practical choice for a new hardware platform, avoiding the need to rely on discontinued or obsolete components.</p>"},{"location":"introduction/why-65c02/#advantages-of-the-65c02","title":"Advantages of the 65C02","text":"<p>The 65C02 is a CMOS version of the original NMOS 6502, bringing several improvements while maintaining compatibility with the original architecture:</p> <ul> <li> <p>Higher clock frequencies:   The CMOS design allows the 65C02 to operate reliably at significantly higher   clock speeds than the original 6502.</p> </li> <li> <p>Reduced power consumption:   CMOS fabrication reduces energy requirements, making the system more efficient   and better suited for modern embedded or battery-powered applications.</p> </li> <li> <p>Expanded instruction set and corrections:   The 65C02 adds new instructions, removes some undefined behaviors of the   original 6502, and introduces small enhancements that simplify system   programming.</p> </li> </ul> <p>These technical improvements result in a processor that maintains historical relevance while providing better performance, reliability, and usability for contemporary designs.</p>"},{"location":"introduction/why-65c02/#summary","title":"Summary","text":"<p>The selection of the 65C02 for the ByteCradle platform reflects a balance between historical appreciation and practical engineering:</p> <ul> <li>It connects users with the foundations of 8-bit computing.</li> <li>It provides a readily available, robust, and energy-efficient processor.</li> <li>It allows exploration of both classic and expanded 6502 programming   techniques.</li> </ul> <p>By using the 65C02, the platform offers a reliable and instructive environment for studying fundamental computer engineering concepts on real hardware.</p>"},{"location":"tutorials/inline-assembler/","title":"Monitor","text":"<p>The MONITOR is a simple program that provides direct control over the system\u2019s memory and CPU execution. It allows you to read and write memory, run code from specific addresses, assemble instructions manually, and disassemble machine code for inspection.</p> <p>Note</p> <p>The description provided here pertains to the <code>/TINY/</code> board, but the instructions are transferable to the <code>/MINI/</code> board. The major difference is that the <code>/MINI/</code> board supports bank switching and has its ROM starting at <code>0xC000</code> where as the <code>/TINY/</code> has ROM starting at <code>0x8000</code>.</p> <p>Upon booting the <code>/TINY/</code> board, you will be greeted with a selection menu which allows you to select the <code>MONITOR</code> option. </p> <pre><code>+----------------------------------------------+\n|             BYTECRADLE MONITOR               |\n+----------------------------------------------+\n| FREE ZERO PAGE :     0x30 - 0xFF             |\n| FREE RAM       : 0x0400 - 0xFF00             |\n| ROM            : 0x8000 - 0xFFFF             |\n+----------------------------------------------+\n| COMMANDS                                     |\n| R&lt;XXXX&gt;[:&lt;XXXX&gt;] read memory                 |\n| W&lt;XXXX&gt;          write to memory             |\n| G&lt;XXXX&gt;          run from address            |\n| A&lt;XXXX&gt;          assemble from address       |\n| D&lt;XXXX&gt;          disassemble from address    |\n| M                show this menu              |\n| Q                quit                        |\n+----------------------------------------------+\n</code></pre>"},{"location":"tutorials/inline-assembler/#monitor-functions","title":"Monitor Functions","text":"<p>The Monitor provides several commands that allow direct interaction with the system's memory and CPU. These functions are essential for writing, testing, and debugging programs at a low level:</p> <ul> <li>Reading memory (<code>R&lt;XXXX&gt;[:&lt;XXXX&gt;]</code>) Allows you to examine memory contents at a   specific address or within a range of addresses.</li> <li>Writing to memory (<code>W&lt;XXXX&gt;</code>) Enables manual modification of memory contents at   a given address. Useful for inserting data like ASCII strings or instructions.</li> <li>Running code (<code>G&lt;XXXX&gt;</code>) Starts execution of code from a specific memory   address, enabling you to run programs you have written or loaded into RAM.</li> <li>Inline assembly (<code>A&lt;XXXX&gt;</code>) Opens an assembler interface at the specified   address, allowing you to input machine code instructions directly in mnemonic   form.</li> <li>Disassembling code (<code>D&lt;XXXX&gt;</code>) Reads machine code from memory and converts it   back into human-readable assembly instructions.</li> <li>Showing the menu (<code>M</code>) Displays the monitor\u2019s command menu and current memory   layout for quick reference.</li> <li>Quitting (<code>Q</code>) Exits the monitor and returns control to the system selection   menu or operating environment.</li> </ul> <p>These functions work together to provide a lightweight but powerful development environment directly on the hardware.</p>"},{"location":"tutorials/inline-assembler/#sample-programs","title":"Sample programs","text":"<p>The following examples demonstrate how to use the Monitor\u2019s inline assembler, memory writing, and program execution features. By manually assembling instructions and inserting data, you can create simple programs directly in memory and run them without needing external tools. These exercises are ideal for learning how the system interacts with memory and the CPU at a low level.</p>"},{"location":"tutorials/inline-assembler/#hello-world","title":"Hello World","text":"<p>Open the inline-assembler using <code>A0400</code> and insert the following assembly instructions:</p> <pre><code>0400: LDA #10       A9 10\n0402: LDX #04       A2 04\n0404: JSR FFE8      20 E8 FF\n0407: RTS           60\n</code></pre> <p>Next, insert the ASCII characters for the string <code>Hello World!</code> by first typing <code>W0410</code> and entering the following values:</p> <pre><code>0410: 48 65 6C 6C 6F 20 57 6F 72 6C 64 21 00\n</code></pre> <p>To run the small program, type <code>G0400</code>.</p> <p>The expected output is:</p> <pre><code>@:G0400\nHello World!\n</code></pre>"},{"location":"tutorials/inline-assembler/#fibonacci-series","title":"Fibonacci series","text":"<p>Open the inline-assembler using <code>A0400</code> and insert the following assembly instructions:</p> <pre><code>0400: LDA #01                  A9 01\n0402: LDX #01                  A2 01\n0404: LDY #00                  A0 00\n0406: PHX                      DA\n0407: PHY                      5A\n0408: JSR FFF4                 20 F4 FF\n040B: JSR FFEE                 20 EE FF\n040E: PLY                      7A\n040F: PLX                      FA\n0410: STX 30                   86 30\n0412: CLC                      18\n0413: PHA                      48\n0414: ADC 30                   65 30\n0416: PLX                      FA\n0417: INY                      C8\n0418: CPY #0C                  C0 0C\n041A: BNE EA                   D0 EA\n041C: RTS                      60\n</code></pre> <p>To run the program, type <code>G0400</code>, which yields the following output:</p> <pre><code>@:G0400\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n</code></pre>"}]}