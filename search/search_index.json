{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ByteCradle 6502 Documentation","text":"<p>The ByteCradle 6502 is a single-board computer (SBC) platform built around the WDC 65C02 microprocessor.   It is designed for learning and experimenting with simple operating systems on 8-bit hardware. Whether you are new to 8-bit computers or an experienced hardware tinkerer, ByteCradle offers an accessible and expandable environment to explore these topics.</p> <p> </p>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"\ud83d\ude80 Getting Started <p>Learn how to assemble the board, power up safely, and run your first program.</p> \ud83d\udda5\ufe0f Hardware Overview <p>Dive deep into the hardware design, schematics, and engineering decisions behind ByteCradle.</p> \ud83d\udcbe Software Overview <p>Explore the codebase and development decisions that power ByteCradle's software stack.</p> \ud83e\uddea Emulator <p>Install and use the emulator to prototype, test, and debug your 65C02 programs.</p> \ud83d\udca1 Tutorials <p>Start coding! Follow step-by-step guides for writing assembly, peripherals control, and debugging.</p> \u2699\ufe0f Advanced Topics <p>Explore system expansion, hardware mods, and building more sophisticated applications.</p>"},{"location":"emulator/emulator-overview/","title":"Emulator Overview","text":"<p>Developing software for the ByteCradle 6502 platform without an emulator involves a tedious and repetitive workflow: you would need to cross-assemble or cross-compile your source code, flash it onto a ROM, physically insert that ROM into the board, and then run the board to test your code. Each cycle can take several minutes and is prone to errors, making rapid development and testing difficult.</p> <p>The <code>bc6502emu</code> emulator removes these barriers by allowing you to run and test your 6502 code directly on a modern computer. It integrates cleanly into your development workflow and enables fast iteration without the need for physical hardware during the early stages of development.</p>"},{"location":"emulator/emulator-overview/#benefits-of-using-an-emulator","title":"Benefits of Using an Emulator","text":"<ul> <li>Rapid testing and iteration: Instantly test code changes without flashing or hardware interaction, dramatically reducing development time.</li> <li>Safe and controlled environment: Reproducible and isolated, ideal for debugging, testing edge cases, and avoiding hardware wear or damage.</li> <li>Simplified debugging: Observe program behavior, simulate input, and analyze results using standard tools on your development machine.</li> <li>Development without hardware: Start writing and validating software even before hardware is available or finalized.</li> <li>Automation and integration: Easily integrate into build systems and CI pipelines for automated testing and validation.</li> </ul>"},{"location":"emulator/emulator-overview/#introducing-bc6502emu","title":"Introducing <code>bc6502emu</code>","text":"<p><code>bc6502emu</code> is a lightweight emulator designed specifically for the ByteCradle 6502 platform. It supports the two board variants:</p> <ul> <li>tiny \u2013 a minimal configuration without SD card storage.</li> <li>mini \u2013 includes SD card image support for simulating file I/O and the 65C22 versatile interface adapter.</li> </ul> <p>With <code>bc6502emu</code>, you can:</p> <ul> <li>Run 6502 binaries directly from your development environment.</li> <li>Simulate SD card behavior (mini variant).</li> <li>Configure the emulated CPU clock speed.</li> <li>Provide terminal input for programs that rely on user interaction.</li> </ul> <p>Ready to get started?</p> <p>Go to the Installing Emulator page to compile and run the emulator.</p>"},{"location":"emulator/installing-emulator/","title":"Installing and Running the Emulator","text":"<p>This guide explains how to compile and run the <code>bc6502emu</code> emulator on a modern POSIX-compatible system. The emulator supports both the <code>tiny</code> and <code>mini</code> variants of the ByteCradle 6502 board and is designed for fast and simple command-line usage.</p>"},{"location":"emulator/installing-emulator/#platform-requirements","title":"Platform Requirements","text":"<p>We assume you are working in a POSIX environment, such as Linux or macOS. For Windows users, we warmly recommend installing  Windows Subsystem for Linux (WSL). All development and testing have been done using Ubuntu, and we recommend it as the reference environment.</p>"},{"location":"emulator/installing-emulator/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure your system meets the following requirements:</p> <ul> <li>A C++17-compatible compiler</li> <li>CMake for managing the build process</li> <li>The TCLAP library for command-line parsing</li> </ul> <p>To install all required dependencies on Ubuntu or Debian-based systems, run:</p> <pre><code>sudo apt update &amp;&amp; sudo apt install build-essential cmake libtclap-dev\n</code></pre> <p>After compilation, the emulator binary will be located in the <code>build</code> directory under the name <code>bc6502emu</code>.</p> <p>Ready to start using the emulator?</p> <p>Go to the Running the Emulator</p>"},{"location":"emulator/running-emulator/","title":"Running the Emulator","text":"<p>Once compiled, you can run the emulator with the following syntax (adjust accordingly for your paths):</p> <pre><code>./bc6502emu --board &lt;tiny|mini&gt; \\\n--rom &lt;path_to_rom&gt; \\\n[--sdcard &lt;path_to_sdcard&gt;] \\\n[--clock &lt;mhz&gt;]\n</code></pre>"},{"location":"emulator/running-emulator/#arguments","title":"Arguments","text":"Argument Description Required <code>-b, --board</code> Select the board type: <code>tiny</code> or <code>mini</code>. Yes <code>-r, --rom</code> Path to the ROM file to load. Yes <code>-s, --sdcard</code> Path to the SD card image (only for <code>mini</code>). No <code>-c, --clock</code> CPU clock speed in MHz (default: 16.0 MHz). No"},{"location":"emulator/running-emulator/#example-usage","title":"Example Usage","text":"<p>To run the emulator with the <code>tiny</code> board:</p> <pre><code>./bc6502emu --board tiny --rom ../../src/tinyrom/tinyrom.bin\n</code></pre> <p>To run the emulator with the <code>mini</code> board and an SD card image:</p> <pre><code>./bc6502emu --board mini --rom ../../src/minirom.bin --sdcard ../scripts/sdcard.img --clock 12.0\n</code></pre> <p>Info</p> <p>For running the <code>/MINI/</code> board, besides the ROM file, you will also need an SD-card image. This SD-card image can be generated using the <code>create_sd.sh</code> script found in the <code>emulator/script</code> folder.</p> <p>Tip</p> <p>For compiling the ROMs, we make use of a <code>Makefile</code>. These <code>Makefile</code> files contain the <code>make run</code> instruction which automatically launches the ROM in the emulator using the right settings. It does assume that the emulator has been compiled in the <code>build</code> folder as explained above.</p>"},{"location":"getting-started/assembling-the-board/","title":"Assembling the Board","text":""},{"location":"getting-started/assembling-the-board/#soldering-components","title":"Soldering Components","text":"<p>When assembling the board, it's best to solder components in order of increasing height. This helps keep parts steady and ensures easier access during soldering. Follow the sequence below to make the process smooth and efficient.</p>"},{"location":"getting-started/assembling-the-board/#tiny-board-assembly-guide","title":"Tiny Board Assembly Guide","text":"<ol> <li> <p>Begin with the resistors: Solder R1 through R6. These are flat and    easiest to place first.</p> </li> <li> <p>Socket for CAN oscillator (X1): If you plan to socket the CAN oscillator,    install its socket now before moving on.</p> </li> <li> <p>Install the DIP sockets: Proceed with U1, U2, and U4 through U7. Note    that U3 does not need a socket.    If your ceramic capacitors are taller than the DIP sockets, consider    soldering the capacitors first (see next step) to avoid height conflicts.</p> </li> <li> <p>Add the ceramic capacitors: Solder C1, C3, and C5 through C10. Also add    C11.    Be careful with C12 \u2014 it should be a 30pF capacitor, while the others are    100nF and usually don\u2019t have markings on the silkscreen.</p> </li> <li> <p>Place the DS1813 component: This goes at U3 and should be inserted    carefully.</p> </li> <li> <p>Install the tactile switches: Mount SW2 and SW3. These are 6mm tall.</p> </li> <li> <p>Solder the LED: Install the 5mm LED at D1, making sure the orientation is    correct.</p> </li> <li> <p>Attach the pin header: Solder the 2x20 male pin header at J2.</p> </li> <li> <p>Install the USB connector: Solder the USB type B connector at J1.</p> </li> <li> <p>Add the serial connector: Install the 9-pin SUBD serial port.</p> </li> <li> <p>Install the 10\u00b5F electrolytic capacitors: Place C2 and C12 through C15.     Watch the polarity \u2014 these capacitors are polarized.</p> </li> <li> <p>Install the 100\u00b5F electrolytic capacitor: Solder C4, also making sure to     observe polarity.</p> </li> <li> <p>Place the oscillator: Insert the 1.8432 MHz crystal oscillator at Y1.</p> </li> <li> <p>Finish with the toggle switch: Finally, install SW1 \u2014 the tallest     component \u2014 to complete the board.</p> </li> </ol> <p>Once all components are soldered, the only remaining task is to insert the chips into their sockets. Be sure to align the chips correctly according to the notch or dot marking on each IC and the corresponding silkscreen indicator on the board.</p>"},{"location":"getting-started/assembling-the-board/#flashing-the-rom","title":"Flashing the ROM","text":"<p>Before powering up your ByteCradle board for the first time, it is essential to flash the appropriate ROM image onto the onboard memory chip. The required ROM chip and image depend on the variant of the board:</p> <ul> <li>ByteCradle Tiny: Uses an SST39SF010 (1 Mbit) chip.</li> <li>ByteCradle Mini: Uses an SST39SF040 (4 Mbit) chip.</li> </ul> <p>Each board requires a specific ROM file that matches its hardware configuration.</p>"},{"location":"getting-started/assembling-the-board/#required-tools","title":"Required Tools","text":"<p>To flash the ROM, you'll need a compatible EPROM/Flash programmer. Options include:</p> <ul> <li>Commercial Programmers:<ul> <li>TL866II Plus: A popular, affordable universal programmer.</li> <li>XGecu T48: A more advanced model supporting a wide range of devices.</li> </ul> </li> <li>Open Source and DIY Alternatives:<ul> <li>Pico-SST39SF0x0 Programmer: A lightweight and affordable programmer using a Raspberry Pi Pico.</li> <li>Arduino-based Flashers: Utilize an Arduino (e.g., Uno) with community firmware for programming simple parallel flash devices.</li> </ul> </li> </ul> <p>Choosing a Flasher</p> <p>Commercial programmers offer ready-to-use software and broad device support. However, open-source solutions like the Pico-SST39SF0x0 Programmer are cost-effective and excellent for DIY enthusiasts.</p>"},{"location":"getting-started/assembling-the-board/#flashing-process-overview","title":"Flashing Process Overview","text":"<ol> <li> <p>Set Up the Programmer:</p> <ul> <li>For the Pico-SST39SF0x0 Programmer:</li> <li>Flash your Raspberry Pi Pico with the firmware from the GitHub repository.</li> <li>Connect the ROM chip to the Pico according to the wiring guide provided in the repository.</li> </ul> </li> <li> <p>Load the ROM File:</p> <ul> <li>Open your flashing software.</li> <li>Select the correct chip type from the supported devices list.</li> <li>Load the appropriate ROM image for your ByteCradle board variant.</li> </ul> </li> <li> <p>Write and Verify:</p> <ul> <li>Erase the chip if necessary (some programmers do this automatically).</li> <li>Write the ROM file to the flash chip.</li> <li>Perform a verification pass to confirm the write was successful.</li> </ul> </li> <li> <p>Install the ROM:</p> <ul> <li>After successful flashing, insert the ROM chip carefully into its socket, ensuring correct orientation.</li> </ul> </li> </ol> <p> Next: Proceed to the first power up</p>"},{"location":"getting-started/first-power-up/","title":"First Power-Up and Testing","text":""},{"location":"getting-started/first-power-up/#hooking-up-the-power-supply","title":"Hooking up the Power Supply","text":"<p>The ByteCradle board requires a 5V power supply capable of delivering at least 500 mA of current. Power is supplied through a USB-B connector. The ByteCradle does not have any on-board power regulation. It is critical to use a reliable and regulated 5V power source to avoid damaging the board. Recommended options include:</p> <ul> <li>A direct connection to a computer USB port</li> <li>A certified USB wall adapter rated for 5V output</li> </ul> <p>Power Supply Safety</p> <p>Avoid using low-quality or unregulated power adapters, as unstable voltages can cause erratic behavior or permanent damage to the board.</p> <p>Power-Up Sequence</p> <p>Before powering up the board, make sure the serial communication cable (see next section) is connected and a serial port has been opened on your computer. This ensures you will see the header information that the board outputs upon boot. If you power on the board before setting up the serial connection, you can still communicate with it, but you will miss the initial startup messages. In that case, simply press the reset button on the board to perform a cold boot and re-trigger the startup sequence.</p>"},{"location":"getting-started/first-power-up/#setting-up-serial-communication","title":"Setting Up Serial Communication","text":"<p>Communication with the ByteCradle platform is handled via a standard RS232 serial interface, implemented using the onboard 65C51 ACIA (Asynchronous Communications Interface Adapter) and a MAX232 line driver. This setup ensures reliable and straightforward serial communication, supporting both TTL and RS232 voltage levels.</p> <p>The default communication settings are:</p> <ul> <li>Baud Rate: 115200</li> <li>Data Bits: 8</li> <li>Parity: None</li> <li>Stop Bits: 1</li> </ul> <p>(commonly referred to as 8N1 configuration).</p> <p>Several tools are available to interface with the board over RS232:</p> <ul> <li>Windows: PuTTY, Tera   Term</li> <li>MacOS: CoolTerm, or the built-in   <code>screen</code> command</li> <li>Linux: Minicom, <code>screen</code>, or   picocom</li> </ul> <p>Finding the correct serial port</p> <ul> <li>On Windows: Open Device   Manager and look under Ports (COM &amp; LPT). Your device will appear as   something like <code>COM3</code>, <code>COM4</code>, etc. </li> <li>On MacOS: Use the command <code>ls /dev/tty.*</code> in Terminal. Look for entries like <code>/dev/tty.usbserial-XXXXX</code>. </li> <li>On Linux: Use <code>ls /dev/ttyUSB*</code> or <code>ls /dev/ttyACM*</code> depending on your   USB-to-serial adapter. Common examples include <code>/dev/ttyUSB0</code>.</li> </ul> <p>Connection Tip</p> <p>After identifying the correct port, configure your terminal program with the settings above and open the connection. Upon powering up the ByteCradle, you should see output from the board if the connection is established correctly.</p>"},{"location":"getting-started/first-power-up/#boot-screen","title":"Boot screen","text":"<p>If everything is working correctly, you should see the following boot screens as shown below.</p> <p>For the  TINY board:</p> <pre><code>+----------------------------------------------+\n| BYTECRADLE /TINY/ ROM                        |\n+----------------------------------------------+\n| RAM  : 0x0000 - 0x7EFF                       |\n| ROM  : 0x8000 - 0xFFFF                       |\n| IO   : 0x7F00 - 0x7FFF                       |\n| ACIA : 0x7F04 - 0x7F0F                       |\n+----------------------------------------------+\n|     SELECT CATEGORY                          |\n|                                              |\n| (t) Test routines                            |\n| (a) Applications                             |\n| (g) Games                                    |\n| (m) Monitor                                  |\n+----------------------------------------------+\n</code></pre> <p>and for the  MINI board:</p> <pre><code> ____             __           ____                      __   ___\n/\\  _`\\          /\\ \\__       /\\  _`\\                   /\\ \\ /\\_ \\\n\\ \\ \\L\\ \\  __  __\\ \\ ,_\\    __\\ \\ \\/\\_\\  _ __    __     \\_\\ \\\\//\\ \\      __\n \\ \\  _ &lt;'/\\ \\/\\ \\\\ \\ \\/  /'__`\\ \\ \\/_/_/\\`'__\\/'__`\\   /'_` \\ \\ \\ \\   /'__`\\\n  \\ \\ \\L\\ \\ \\ \\_\\ \\\\ \\ \\_/\\  __/\\ \\ \\L\\ \\ \\ \\//\\ \\L\\.\\_/\\ \\L\\ \\ \\_\\ \\_/\\  __/\n   \\ \\____/\\/`____ \\\\ \\__\\ \\____\\\\ \\____/\\ \\_\\\\ \\__/.\\_\\ \\___,_\\/\\____\\ \\____\\\n    \\/___/  `/___/&gt; \\\\/__/\\/____/ \\/___/  \\/_/ \\/__/\\/_/\\/__,_ /\\/____/\\/____/\n               /\\___/\n               \\/__/\n  ____  ______     __      ___\n /'___\\/\\  ___\\  /'__`\\  /'___`\\\n/\\ \\__/\\ \\ \\__/ /\\ \\/\\ \\/\\_\\ /\\ \\\n\\ \\  _``\\ \\___``\\ \\ \\ \\ \\/_/// /__\n \\ \\ \\L\\ \\/\\ \\L\\ \\ \\ \\_\\ \\ // /_\\ \\\n  \\ \\____/\\ \\____/\\ \\____//\\______/\n   \\/___/  \\/___/  \\/___/ \\/_____/\n\nStarting system.\nClearing user space...   [OK]\nConnecting to SD-card... [OK]\n:/&gt;\n</code></pre>"},{"location":"getting-started/required-tools/","title":"Required Tools","text":"<p>The tools you'll need depend on whether you're assembling the board yourself or working with a pre-assembled unit.</p>"},{"location":"getting-started/required-tools/#for-manual-assembly","title":"For Manual Assembly","text":"<p>If you're starting from a bare PCB and sourcing your own components, ensure you have the following tools and equipment:</p> <ul> <li>Soldering iron \u2014 Preferably temperature-controlled for best results.</li> <li>Solder \u2014 Leaded solder is typically easier to work with, but choose   according to your preference or safety requirements.</li> <li>ROM flasher \u2014 A reliable, advanced commercial flasher such as the XGecu   PRO, which supports programming Atmel SST39SF0X0 series chips.</li> </ul>"},{"location":"getting-started/required-tools/#board-specific-requirements","title":"Board-Specific Requirements","text":"<ul> <li>For  TINY boards: A flasher that supports programming ATF22V10 chips.</li> <li>For  MINI boards: A flasher compatible with ATF1502AS chips.</li> </ul>"},{"location":"getting-started/required-tools/#for-pre-assembled-boards","title":"For Pre-Assembled Boards","text":"<p>If you're using a board that has already been assembled, your tool requirements are simpler:</p> <ul> <li>A SST39SF0X0-compatible flasher \u2014 Many affordable and widely available   flashers support this chip family.</li> </ul> <p>Tip</p> <p>While high-end flashers like the XGecu PRO are recommended for reliability, budget-friendly options may suffice for casual use, especially with pre-assembled boards. A budget-friendly option is the PICO-SST39SF0x0-programmer.</p> <p> Next: Proceed to assembling the board</p>"},{"location":"hardware/board-overview/","title":"Board Overview","text":""},{"location":"hardware/board-overview/#tier-system-overview","title":"Tier System Overview","text":"<p>ByteCradle\u2019s hardware platform is designed with flexibility and accessibility in mind, offering a scalable ecosystem for retro computing enthusiasts, embedded developers, and educational environments. It features a tiered architecture to accommodate both minimalistic setups and more capable systems, ensuring a smooth learning curve while supporting increasingly complex applications. Each tier is carefully engineered to balance performance, expandability, and simplicity, making it easy to dive into 65xx-based system design, from first experiments to advanced custom builds.</p>"},{"location":"hardware/board-overview/#tiny-sbc","title":"Tiny SBC","text":"<ul> <li>Simplified design with a small footprint.</li> <li>Memory: 32 KiB RAM and 32 KiB ROM.</li> <li>Programmable logic: Utilizes small PLDs to minimize discrete components.</li> <li>Ideal for learning, experimentation, and small embedded projects.</li> </ul> <p>\ud83d\udd0d View schematic</p> <p> </p>"},{"location":"hardware/board-overview/#mini-sbc","title":"Mini SBC","text":"<ul> <li>Advanced design with bank switching for greater memory capabilities.</li> <li>Memory: 512 KiB of RAM and 512 KiB of ROM (bank-switched).</li> <li>Programmable logic: Built around CPLDs for greater integration.</li> <li>Includes a 65C22 VIA to interface with an SD card for persistent   storage and potential peripheral expansion.</li> <li>Perfect for exploring larger applications, file systems, and   system-level programming.</li> </ul> <p>\ud83d\udd0d View schematic</p> <p> </p>"},{"location":"hardware/board-overview/#feature-comparison","title":"Feature Comparison","text":"Feature Tiny SBC Mini SBC Frequency 16 MHz 12 MHz RAM 32 KiB 512 KiB (bank switched) ROM 32 KiB 512 KiB (bank switched) Bank Switching \u274c \u2705 (64 \u00d7 8 KiB banks) SD Card Support \u274c \u2705 (via 65C22 VIA) Serial Interface 65C51 ACIA 65C51 ACIA I/O mapping ATF22V10 ATF1502 Expansion Options Exposes system bus Exposes system bus and VIA bus"},{"location":"hardware/board-overview/#programmable-logic","title":"Programmable logic","text":"<p>Both ByteCradle boards use programmable logic devices, a ATF22V10 PLD in the  TINY board and a ATF1502 CPLD for the  MINI board. These chips handle essential control logic like address decoding, chip selects, and bank switching. These devices replace traditional discrete logic chips (such as 74-series TTL), resulting in faster, more compact, and more reliable designs.</p>"},{"location":"hardware/board-overview/#tiny-board-atf22v10","title":"Tiny Board - ATF22V10","text":"<p>The  TINY Board uses an ATF22V10 PLD to implement address decoding and I/O mapping for RAM, ROM, and the ACIA serial interface. This chip allows tight integration of logic without chaining multiple discrete components, which reduces propagation delays. Its internal logic can respond in under 10\u202fns, enabling the system to run stably at 16\u202fMHz\u2014much faster than typical retro systems.</p>"},{"location":"hardware/board-overview/#mini-board-atf1502","title":"Mini Board - ATF1502","text":"<p>The  MINI Board uses an ATF1502 CPLD, which offers significantly more logic resources. It handles complex tasks like dynamic RAM and ROM bank switching, peripheral selection, and reading/writing to the bank registers. Updates can be made through JTAG without changing hardware. The CPLD's deterministic timing is critical for maintaining stability at 12\u202fMHz.</p>"},{"location":"hardware/memory-maps/","title":"Memory Maps","text":""},{"location":"hardware/memory-maps/#tiny-board","title":"Tiny Board","text":"<p>The  TINY board uses a flat 64 KiB memory map typical of 65C02-based systems. The first 256 bytes (<code>$0000\u2013$00FF</code>) are Zero Page RAM, followed by the stack at <code>$0100\u2013$01FF</code>. The range <code>$0200\u2013$03FF</code> is reserved for OS use, while <code>$0400\u2013$7EFF</code> serves as general-purpose RAM.</p> <p>A small I/O region at <code>$7F00\u2013$7FFF</code> includes only <code>$7F04\u2013$7F07</code>, which is connected to a 65C51 ACIA UART for serial communication. The remainder of the I/O space is currently unused but mapped to RAM, meaning it is technically accessible for reads and writes. However, using this area is not recommended, as future hardware revisions may repurpose it. Users may also reconfigure the address decoding logic by updating the ATF22V10 chip to change or expand the I/O mapping as needed.</p> <p>The upper 32 KiB (<code>$8000\u2013$FFFF</code>) is mapped to ROM, containing system firmware such as a monitor or BASIC interpreter.</p> Address Range Size Description <code>$0000-$00FF</code> 256 bytes Zero Page RAM <code>$0100-$01FF</code> 256 bytes Stack <code>$0200-$03FF</code> 512 bytes Reserved (OS Use) <code>$0400-$7EFF</code> ~31 KiB General Purpose RAM <code>$7F00-$7F03</code> 4 bytes Unused / Reserved <code>$7F04-$7F07</code> 4 bytes ACIA (UART) <code>$7F08-$7FFF</code> 248 bytes Unused / Reserved <code>$8000-$FFFF</code> 32 KiB ROM"},{"location":"hardware/memory-maps/#mini-board","title":"Mini Board","text":"<p>The  MINI board features a flexible 64 KiB memory map designed to support both fixed and bank-switched memory regions. The lower memory (<code>$0000\u2013$7EFF</code>) is primarily RAM, with the first 256 bytes (<code>$0000\u2013$00FF</code>) allocated as Zero Page, and the next 256 bytes (<code>$0100\u2013$01FF</code>) serving as the stack. Addresses <code>$0200\u2013$07FF</code> are reserved for OS-level functionality, while the remainder up to <code>$7EFF</code> is available as general-purpose RAM, implemented across fixed banks 0\u20133.</p> <p>The region <code>$7F00\u2013$7FFF</code> is dedicated to memory-mapped I/O, divided into four 64-byte blocks using only address lines A6 and A7. The first block (<code>$7F00\u2013$7F3F</code>) connects to a 65C51 ACIA for serial communication, while the second (<code>$7F40\u2013$7F7F</code>) maps to a 6522 VIA. The remaining two blocks (<code>$7F80\u2013$7FBF</code> and <code>$7FC0\u2013$7FFF</code>) are used to write to the ROM and RAM bank registers, respectively.</p> <p>The upper half of the address space is split between banked and fixed ROM/RAM. The ranges <code>$8000\u2013$9FFF</code> and <code>$A000\u2013$BFFF</code> are bank-switched RAM and ROM windows, supporting 64 banks each. The final 16 KiB (<code>$C000\u2013$FFFF</code>) is mapped to fixed ROM, permanently connected to banks 0 and 1, containing  critical system firmware.</p> <p>Warning</p> <p>The bank-switched ROM and RAM regions (<code>$A000\u2013$BFFF</code> and <code>$8000\u2013$9FFF</code>) share the same physical memory space as the fixed ROM (<code>$C000\u2013$FFFF</code>) and fixed RAM (<code>$0000\u2013$7EFF</code>), respectively. This means that selecting ROM banks 0\u20131 or RAM banks 0\u20133 will expose the same physical memory already mapped in the fixed regions. For example, if RAM bank 0 is selected, writes may unintentionally modify the stack or zero page; selecting ROM bank 0 might interfere with the interrupt vectors or firmware routines.  </p> <p>While overlapping ROM banks are less problematic\u2014since ROM is typically read-only and cannot be written to\u2014it can still cause confusion or redundancy if the same code or data appears in both fixed and banked areas. It is strongly recommended to begin using RAM banks from 4 upwards and ROM banks from 2 upwards to avoid overlapping with fixed memory areas and ensure predictable behavior.</p> Address Range Size Description <code>$0000-$00FF</code> 256 bytes Zero Page RAM <code>$0100-$01FF</code> 256 bytes Stack <code>$0200-$07FF</code> 512 bytes Reserved (used by BCOS) <code>$0800-$7EFF</code> 30 KiB General Purpose RAM (Fixed, Banks 0\u20133) <code>$7F00-$7F3F</code> 64 bytes ACIA (UART) <code>$7F40-$7F7F</code> 64 bytes VIA <code>$7F80-$7FBF</code> 64 bytes ROM Bank Register <code>$7FC0-$7FFF</code> 64 bytes RAM Bank Register <code>$8000-$9FFF</code> 8 KiB Bank-switched RAM Window (Banks 0\u201363) <code>$A000-$BFFF</code> 8 KiB Bank-switched ROM Window (Banks 0\u201363) <code>$C000-$FFFF</code> 16 KiB Fixed ROM (Banks 0\u20131 mapped permanently)"},{"location":"hardware/schematics-layout/","title":"Board Schematics","text":"<p>The schematics for the  TINY and  MINI boards are provided in SVG format, which allows for infinite scaling without any loss of detail. This makes them ideal for inspection, printing, or embedding in other documents. Simply click on any image to view it full-size in your browser or download it directly for offline use.</p>"},{"location":"hardware/schematics-layout/#tiny","title":"Tiny","text":""},{"location":"hardware/schematics-layout/#mini","title":"Mini","text":""},{"location":"introduction/what-is-platform/","title":"Introducing the ByteCradle 6502 Platform","text":"<p>In the 1970s, the future of personal computing was 8-bit. Microcomputers and home computers of the era almost universally began with 8-bit processors. The legacy of this era still shapes computing today \u2014 the prominence of the byte as a standard unit of storage and data is a direct inheritance from these early systems.</p> <p>The ByteCradle 6502 embraces this legacy. It is a hands-on, 8-bit computing platform built around the WDC 65C02 microprocessor, a modern variant of the classic MOS 6502. Designed for hobbyists, educators, and retrocomputing enthusiasts, the ByteCradle 6502 offers a practical gateway into low-level system design, assembly programming, and hardware experimentation \u2014 all in the spirit of the early home computer revolution.</p>"},{"location":"introduction/what-is-platform/#tier-system-overview","title":"Tier System Overview","text":"<p>The platform is structured into two distinct tiers, each designed to balance functionality and cost. Lower tiers offer more affordable options, but with reduced feature sets compared to higher tiers.</p>"},{"location":"introduction/what-is-platform/#tiny-sbc","title":"Tiny SBC","text":"<ul> <li>65C02 processor running at 16 MHz</li> <li>Simplified design with a small footprint.</li> <li>Memory: 32 KiB RAM and 32 KiB ROM.</li> <li>I/O communication via a 65C51 ACIA.</li> <li>Programmable logic: Utilizes small PLDs to minimize discrete components.</li> <li>Ideal for learning, experimentation, and small embedded projects.</li> </ul>"},{"location":"introduction/what-is-platform/#mini-sbc","title":"Mini SBC","text":"<ul> <li>65C02 processor running at 12 MHz</li> <li>Advanced design with bank switching for greater memory capabilities.</li> <li>Memory: 512 KiB of RAM and 512 KiB of ROM (bank-switched).</li> <li>I/O communication via a 65C51 ACIA.</li> <li>Programmable logic: Built around CPLDs for greater integration.</li> <li>Includes a 65C22 VIA to interface with an SD card for persistent   storage and potential peripheral expansion.</li> <li>Perfect for exploring larger applications, file systems, and   system-level programming.</li> </ul>"},{"location":"introduction/why-65c02/","title":"Why the 65C02?","text":"<p>    65C02 processor from Western Design Center </p>"},{"location":"introduction/why-65c02/#choosing-the-right-cpu","title":"Choosing the Right CPU","text":"<p>At the outset of this project, one of the most critical decisions was selecting a CPU architecture. Several classic 8-bit and 16-bit processors were considered \u2014 notably the MOS 6502, Zilog Z80, and Intel 8088/8086.</p> <p>Each of these CPUs played a foundational role in early personal computing. However, important practical considerations shaped the final choice:</p> <ul> <li>The 8088/8086, though historically significant, is no longer in   production.</li> <li>The Z80, another strong contender, also recently ceased production \u2014   though both it and the 8086 remain available through surplus and legacy   channels.</li> <li>The WDC 65C02, a modern CMOS variant of the original 6502, is still in   active production. It not only has robust commercial support but also   carries the legacy of influential systems like the Apple II, Commodore   64, BBC Micro, and NES.</li> </ul> <p>This combination of availability, legacy, and technical elegance made the 65C02 a natural choice.</p>"},{"location":"introduction/why-65c02/#instruction-set-simplicity","title":"Instruction Set Simplicity","text":"<p>One of the most compelling arguments in favor of the 6502 \u2014 especially for a learning-oriented platform \u2014 is its simplicity. Its architecture and instruction set are compact and easy to grasp, making it particularly approachable for those new to assembly language or low-level system design.</p> <p>Here's a comparative look at instruction set sizes:</p> CPU Approximate Number of Instructions Notes 6502 ~56 Small, minimal instruction set; easy to memorize 65C02 ~70 Enhanced 6502 with additional instructions and fixed quirks 65C816 ~92 16-bit extension of 65C02; backward-compatible, adds new registers 8080 ~78 Slightly more complex, more registers than 6502 Z80 ~158 Includes extended opcodes, prefixes, and register pairs 8086/88 ~133 16-bit instructions, multi-byte ops, complex syntax and segments <p>Note</p> <p>Instruction counts are approximate because architectures differ in how they handle prefixes, variants, addressing modes, and unofficial or undocumented opcodes. Extended CPUs (like Z80 or 65C816) often reuse base instructions with added functionality.</p> <p>While instruction count isn't the sole measure of complexity, it does reflect how minimal and focused the 6502 is. In contrast, the 8080 and Z80 offer richer feature sets that can also present steeper learning curves.</p> <p>Subjectivity note</p> <p>The ease of programming in assembly is naturally a matter of opinion. However, there is broad consensus that the 6502 is beginner-friendly, largely due to its straightforward instruction set and predictable behavior.</p> <p>By building this platform around the 6502, we aim to blend historical relevance with practical accessibility, offering a compelling environment for both exploration and education in low-level computing.</p>"},{"location":"references/datasheets/","title":"Datasheets","text":"<p>This page provides quick access to technical datasheets for the key components used in the ByteCradle platform. These documents include pinouts, electrical characteristics, timing diagrams, and functional descriptions.</p>"},{"location":"references/datasheets/#core-components","title":"\ud83d\udd79\ufe0f Core Components","text":"<ul> <li>W65C02S \u2013 8-bit CMOS Microprocessor</li> <li>W65C22 \u2013 Versatile Interface Adapter (VIA)</li> <li>W65C51N \u2013 Asynchronous Communications Interface Adapter (ACIA)</li> </ul>"},{"location":"references/datasheets/#memory","title":"\ud83e\udde0 Memory","text":"<ul> <li>AS6C4008 \u2013 512K x 8 Low Power CMOS SRAM</li> <li>AS6C62256 \u2013 32K x 8 Low Power CMOS SRAM</li> <li>SST39SF0x0 \u2013 Parallel Flash Memory Series</li> </ul>"},{"location":"references/datasheets/#programmable-logic","title":"\ud83e\udde9 Programmable Logic","text":"<ul> <li>ATF1502AS \u2013 CPLD (Complex Programmable Logic Device)</li> <li>ATF22V10 \u2013 High-Performance PLD</li> </ul>"},{"location":"references/external-links/","title":"External Links","text":"<p>This page contains a collection of helpful external resources related to the 6502 microprocessor, covering documentation, tools, tutorials, and communities.</p>"},{"location":"references/external-links/#general-information","title":"\ud83e\udde0 General Information","text":"<ul> <li> <p>6502.org   A comprehensive site dedicated to the 6502, including datasheets, hardware projects, and programming guides.</p> </li> <li> <p>The MOS 6502 Wikipedia Entry   A good general overview of the 6502\u2019s history, architecture, and applications.</p> </li> </ul>"},{"location":"references/external-links/#programming-resources","title":"\ud83d\udcda Programming Resources","text":"<ul> <li> <p>Easy 6502   An interactive tutorial for learning 6502 assembly language from scratch.</p> </li> <li> <p>CC65 Toolchain   Official documentation for the cc65 C compiler and suite targeting 6502 systems.</p> </li> <li> <p>The 6502 Instruction Set   Detailed breakdown of opcodes and addressing modes.</p> </li> <li> <p>Ben Eater\u2019s 6502 Computer Series   A fantastic hands-on video series building a 6502 computer from scratch and programming it.</p> </li> </ul>"},{"location":"references/external-links/#tools","title":"\ud83d\udee0\ufe0f Tools","text":"<ul> <li> <p>Visual 6502   A transistor-level simulation of the 6502 CPU\u2014see it run in your browser.</p> </li> <li> <p>Emulators and Simulators (6502.org)   A list of software emulators and simulators for developing and testing 6502 code.</p> </li> </ul>"},{"location":"references/external-links/#community","title":"\ud83d\udcac Community","text":"<ul> <li> <p>6502.org Forums   A community of hobbyists and experts discussing hardware, software, and projects.</p> </li> <li> <p>r/6502 on Reddit   A Reddit community for sharing 6502 tips, projects, and questions.</p> </li> </ul> <p>Have a great resource to suggest? Feel free to open a pull request or issue!</p>"},{"location":"software/building-programs/","title":"Building programs","text":""},{"location":"software/building-programs/#introduction","title":"Introduction","text":"<p>This page explains how to build stand-alone programs for the ByteCradle system using the cc65 toolchain, a complete suite for developing software targeting the 65(C)02 processor. It covers the full development workflow, including tool installation, memory layout planning, linker configuration, and Makefile-based build processes for both assembly and C-based programs.</p> <p>A key concept in this process is cross-compilation, the practice of building software on a modern host system (such as Linux, macOS, or Windows) that is intended to run on a different target system, in this case, a 6502-based platform like ByteCradle. Since the target hardware is typically much more limited and may not support native development tools, cross-compilation enables developers to leverage the power and convenience of modern systems to build code for retro or embedded environments.</p> <p>By following this guide, you will learn how to prepare your code and toolchain for effective cross-compilation and deploy programs to either target system using the appropriate method\u2014file-based for ByteCradle OS, or raw memory writes for TinyROM.</p>"},{"location":"software/building-programs/#toolchain","title":"Toolchain","text":"<p>The cc65 toolchain is a complete suite of tools for developing software for 6502-based systems. It includes:</p> <ul> <li><code>cc65</code> \u2013 A C compiler for the 6502 processor</li> <li><code>ca65</code> \u2013 A macro assembler</li> <li><code>ld65</code> \u2013 A powerful linker with configurable memory mapping</li> <li><code>ar65</code> \u2013 An archiver for managing libraries</li> <li><code>od65</code>, <code>da65</code>, and more \u2013 Tools for object file inspection and disassembly</li> </ul> <p>This toolchain is ideal for both assembly and C-based development for the ByteCradle system.</p>"},{"location":"software/building-programs/#installing-cc65-on-ubuntu-linux","title":"Installing cc65 on Ubuntu (Linux)","text":"<p>To install the toolchain and supporting build tools on Ubuntu, follow these steps:</p> <pre><code>sudo apt update\nsudo apt install -y cc65 make\n</code></pre>"},{"location":"software/building-programs/#windows-subsystem-for-linux","title":"Windows Subsystem for Linux","text":"<p>On Windows, the easiest way to use cc65 is through WSL (Windows Subsystem for Linux), which lets you run Linux tools natively:</p> <p>Install WSL by running this in PowerShell (as Administrator):</p> <pre><code>wsl --install\n</code></pre> <p>After rebooting, open the Ubuntu app from the Start Menu.</p> <p>Then run the same commands as on Ubuntu:</p> <pre><code>sudo apt update\nsudo apt install -y cc65 make\n</code></pre> <p>This gives you a clean, Linux-based development environment that integrates well with editors like Visual Studio Code.</p>"},{"location":"software/building-programs/#writing-stand-alone-software","title":"Writing stand-alone software","text":"<p>A stand-alone program is a self-contained executable that is loaded into RAM and run directly under the control of the system's firmware or operating system. Unlike more complex environments with memory protection or multitasking, these programs run in a simple, flat memory model and are responsible for managing their own execution context.</p> <p>In the ByteCradle ecosystem, stand-alone programs are typically loaded into memory either from a ROM device or over UART. Once loaded, they are executed by the system without the aid of a loader or process isolation. Because the 6502 architecture does not provide protected mode or automatic resource management, a stand-alone program must take full responsibility for:</p> <ul> <li>Preserving system integrity: The program must leave the system in a consistent   state when it finishes, including cleaning up the stack and registers as needed.</li> <li>Memory management: The program must fit within the memory region made   available by the environment.<ul> <li>Under TinyROM,    this region spans from $0400 to $7EFF.</li> <li>Under the ByteCradle Operating System,    it spans from $0800 to $7EFF.</li> </ul> </li> <li>Stack usage: The program shares the system stack at page $01xx (starting at   $0100) with the operating system. If compiled with cc65, the program may also   use a soft stack (an emulated stack in RAM), which consumes additional memory.</li> </ul> <p>It is the responsibility of the program's author to ensure that the code, data, heap, and any stack usage\u2014both hardware and soft\u2014remain within these limits, avoiding conflicts with the operating system and ensuring reliable execution.</p>"},{"location":"software/building-programs/#program-lay-out","title":"Program lay-out","text":"<p>The way stand-alone programs are stored and loaded differs between TinyROM and the ByteCradle Operating System, reflecting the capabilities of each environment.</p> <ul> <li> <p>TinyROM is a minimal operating system and does not include a file system. As a   result, stand-alone programs for TinyROM are treated as raw binary data,   directly placed into memory. These binaries are typically loaded at a known   memory address (usually starting at $0400) and executed from there. Since   there is no file metadata or structured loading mechanism, the user or host   system must know exactly where and how to place the binary in memory.</p> </li> <li> <p>ByteCradle OS includes a simple file system with support for named files using   the 8.3 filename format (eight-character name, three-character extension).   Executable stand-alone programs use the .COM extension, consistent with legacy   CP/M-style conventions. Each .COM file begins with a two-byte little-endian   value that specifies the deployment address\u2014the memory location where the   program should be loaded before execution. For most stand-alone programs, this   address is $0800, encoded as 00 08 (least significant byte first). This small   header allows the OS to automatically place the program in memory at the   correct location, simplifying the loading process compared to TinyROM's raw   approach.</p> </li> </ul>"},{"location":"software/building-programs/#configuration-files-and-linker","title":"Configuration files and linker","text":"<p>To create an executable for the ByteCradle system, the process typically involves compiling or assembling the source code, followed by a linking step:</p> <ul> <li>Compiling (if written in C): The C source file is translated into intermediate   object code using cc65, the C compiler.</li> <li>Assembling (if written in 6502 assembly): The assembly source is assembled   into object code using ca65, the assembler.</li> <li>Linking: All object files are combined into a final binary using ld65, the   linker. This step determines where each part of the program will reside in   memory.</li> </ul> <p>The linker relies on a linker configuration file (.cfg) to guide how code and data are placed in memory. This configuration file serves as a map of the system's memory\u2014defining which regions are available, where segments should go, and how the output binary should be structured.</p>"},{"location":"software/building-programs/#assembly","title":"Assembly","text":"<p>Below is a minimal linker configuration file used to build a stand-alone program for the ByteCradle Operating System in assembly.</p> <pre><code>MEMORY {\n    HEADER: start = $0800, size = 2, file = %O;             # Explicit start position\n    ROM:    start = $0802, size = $7FFE, file = %O;         # Start right after HEADER\n}\n\nSEGMENTS {\n    HEADER: load = HEADER, type = ro, define = yes;\n    CODE:   load = ROM, type = ro;\n}\n</code></pre> <ul> <li><code>MEMORY</code> block:<ul> <li><code>HEADER</code> defines the first 2 bytes of the output file, starting at $0800.    These bytes contain the deployment address in little-endian format (00 08) and    are used by ByteCradle OS to know where to load and run the program.</li> <li><code>ROM</code> begins immediately after the header (at $0802) and holds the actual   program code.</li> </ul> </li> <li><code>SEGMENTS</code> block:<ul> <li><code>HEADER</code> is linked into the HEADER memory region. Typically, the assembly   source includes this manually as a .word $0800.</li> <li><code>CODE</code> refers to the main code segment, which is placed into the ROM   region starting at $0802.</li> </ul> </li> </ul> <p>This structure matches the ByteCradle OS convention for .COM executables, where files begin with a 2-byte deployment address. The remainder of the file is loaded into memory at that address and executed.</p>"},{"location":"software/building-programs/#c-programs","title":"C programs","text":"<p>Compiled C programs have more complex requirements than simple assembly programs. The compiler and runtime system expect multiple segments for code, data, initialization routines, and memory management. The <code>.cfg</code> file configures how those segments are placed in memory and is essential for successful linking using <code>ld65</code>.</p> <pre><code>MEMORY {\n    ZP:     start = $50, size = $B0, type = rw, define = yes;\n    HEADER: start = $0800, size = 2, file = %O;\n    RAM:    start = $0802, size = $7700-$0802, type = rw, define = yes;\n    STACK:  start = $7700, size = $0800, type = rw, define = yes;\n}\n\nSEGMENTS {\n    ZEROPAGE: load = ZP,        type = zp,  define   = yes;\n    HEADER:   load = HEADER,    type = ro,  define   = yes;\n    STARTUP:  load = RAM,       type = ro;\n    CODE:     load = RAM,       type = ro;\n    ONCE:     load = RAM,       type = ro,  optional = yes;\n    RODATA:   load = RAM,       type = ro;\n    DATA:     load = RAM,       type = rw,  define   = yes, run = RAM;\n    BSS:      load = RAM,       type = bss, define   = yes;\n    HEAP:     load = RAM,       type = bss, optional = yes;\n}\n\nFEATURES {\n    CONDES:    segment = STARTUP,\n               type    = constructor,\n               label   = __CONSTRUCTOR_TABLE__,\n               count   = __CONSTRUCTOR_COUNT__;\n    CONDES:    segment = STARTUP,\n               type    = destructor,\n               label   = __DESTRUCTOR_TABLE__,\n               count   = __DESTRUCTOR_COUNT__;\n}\n\nSYMBOLS {\n    # Define the stack size for the application\n    __STACKSIZE__:  value = $0200, type = weak;\n}\n</code></pre>"},{"location":"software/building-programs/#memory-block","title":"MEMORY Block","text":"<ul> <li> <p>ZP: Defines a section in zero page RAM (<code>$0050\u2013$00FF</code>) for variables that   benefit from fast zero-page addressing. Many cc65 runtime features rely on   this region.</p> </li> <li> <p>HEADER: Occupies the first two bytes at <code>$0800</code>. It stores the deployment   address in little-endian format (typically <code>00 08</code>), which is used by the   ByteCradle OS to determine where to load and execute the program.</p> </li> <li> <p>RAM: This is the main region used for program code, read-only data,   initialized data, and uninitialized data. It starts at <code>$0802</code>, immediately   after the header, and ends just before the stack.</p> </li> <li> <p>STACK: Defines a dedicated memory area for the hardware stack, beginning   at <code>$7700</code> and sized to 2 KB (ending at <code>$7EFF</code>). This keeps stack usage   isolated from the rest of the program.</p> </li> </ul>"},{"location":"software/building-programs/#segments-block","title":"SEGMENTS Block","text":"<p>This section defines how various parts of the program are mapped into the memory regions defined above.</p> <ul> <li> <p>ZEROPAGE: Holds variables that reside in the zero page. These are accessed   more efficiently by the 6502 and are typically used for frequently accessed or   performance-critical data.</p> </li> <li> <p>HEADER: Contains the two-byte deployment address used by the ByteCradle OS   loader.</p> </li> <li> <p>STARTUP: Contains startup routines provided by the cc65 runtime (such as   <code>crt0</code>) that initialize the system before <code>main()</code> is called.</p> </li> <li> <p>CODE: The main compiled C code.</p> </li> <li> <p>ONCE: Optional segment for code that is executed once and can be discarded   afterward.</p> </li> <li> <p>RODATA: Read-only data such as string literals and constants.</p> </li> <li> <p>DATA: Holds initialized global and static variables.</p> </li> <li> <p>BSS: Contains uninitialized global and static variables. This area is   zeroed at runtime before <code>main()</code> executes.</p> </li> <li> <p>HEAP: Optional segment for dynamically allocated memory (used by   <code>malloc()</code> and similar functions).</p> </li> </ul>"},{"location":"software/building-programs/#features-block","title":"FEATURES Block","text":"<p>This section configures constructor and destructor support in the cc65 runtime.</p> <ul> <li><code>__CONSTRUCTOR_TABLE__</code> and <code>__DESTRUCTOR_TABLE__</code> define where initialization   and cleanup function pointers are stored. These are called automatically   before and after <code>main()</code>.</li> </ul>"},{"location":"software/building-programs/#symbols-block","title":"SYMBOLS Block","text":"<ul> <li>Defines the application\u2019s hardware stack size as 512 bytes (<code>$0200</code>), which   can be overridden at link time or in code because it is declared as a weak   symbol.</li> </ul>"},{"location":"software/building-programs/#compilation","title":"Compilation","text":"<p>While it is possible to compile and link programs manually using command-line tools, using a Makefile provides a more efficient and repeatable way to manage builds\u2014especially as a project grows. A Makefile ensures that only the necessary parts of the build are recompiled when changes are made, saving time and reducing errors.</p> <p>Tip</p> <p>For a more detailed tutorial on how to write a stand-alone program, consider the Hello World in assembly and  Hello World in C tutorials.</p>"},{"location":"software/building-programs/#makefile-for-assembly-source","title":"Makefile for assembly source","text":"<p>Below is a simple example of a Makefile used to compile a stand-alone assembly program written for the ByteCradle system. This example assumes a single <code>.asm</code> source file and a custom linker configuration (<code>.cfg</code>) file:</p> <pre><code>PROG = HELLO.COM\nOBJ  = helloworld.o\nCFG  = rom.cfg\n\nall: $(PROG)\n\n$(OBJ): helloworld.asm\n    ca65 helloworld.asm -o $(OBJ)\n\n$(PROG): $(OBJ)\n    ld65 -o $(PROG) -C $(CFG) $(OBJ)\n</code></pre>"},{"location":"software/building-programs/#makefile-for-c-source","title":"Makefile for C-source","text":"<p>This example <code>Makefile</code> demonstrates how to compile and link a C program for the ByteCradle system using the cc65 toolchain. It combines C source code (<code>main.c</code>) with a custom startup file (<code>crt0.s</code>) and links against a library to produce a standalone executable.</p> <pre><code>PROG = FIBO.COM\n\nall: $(PROG)\n\n$(PROG): prog.cfg crt0.o main.o prog.lib\n    ar65 a prog.lib crt0.o\n    ld65 -C prog.cfg -m main.map main.o -o $(PROG) prog.lib\n\ncrt0.o: crt0.s\n    ca65 --cpu 65c02 crt0.s\n\nmain.s: main.c\n    cc65 -t none -O --cpu 65c02 main.c\n\nprog.lib: crt0.o\n    cp -v /usr/share/cc65/lib/supervision.lib prog.lib \n    ar65 a prog.lib crt0.o\n\nmain.o: main.s\n    ca65 --cpu 65c02 main.s\n\nclean:\n    rm -v *.bin *.o *.lib\n</code></pre> <p>The build process consists of the following steps:</p> <ul> <li>Compile the C source (<code>main.c</code>) to assembly using <code>cc65</code></li> <li>Assemble both the generated assembly and a custom startup file (<code>crt0.s</code>)   using <code>ca65</code></li> <li>Combine the startup object with a lightweight runtime library   (<code>supervision.lib</code>) into a static library using <code>ar65</code></li> <li>Link the object files and library into a final binary using <code>ld65</code>, guided by   a linker configuration file (<code>prog.cfg</code>)</li> <li>The result is a <code>.COM</code> file that starts with a 2-byte load address and is   ready to run on ByteCradle OS</li> </ul>"},{"location":"software/building-programs/#explanation-of-makefile-targets","title":"Explanation of Makefile Targets","text":"<ul> <li> <p><code>PROG = FIBO.COM</code>: Specifies the output binary name. <code>.COM</code> is the standard   extension for executables under ByteCradle OS.</p> </li> <li> <p><code>all</code>: Default target, builds the complete program.</p> </li> <li> <p><code>main.c \u2192 main.s</code>: The C compiler <code>cc65</code> translates the C source into 6502   assembly. The <code>-t none</code> flag disables platform-specific features, and <code>--cpu   65c02</code> targets the 65C02 processor used by ByteCradle.</p> </li> <li> <p><code>main.s \u2192 main.o</code>: The assembler <code>ca65</code> compiles the assembly into an object   file.</p> </li> <li> <p><code>crt0.s \u2192 crt0.o</code>: Custom startup code, also assembled with <code>ca65</code>. This   typically includes the program\u2019s entry point and the call to <code>main()</code>.</p> </li> <li> <p><code>prog.lib</code>: A static library created by first copying <code>supervision.lib</code> (from   the cc65 library directory) and then adding the startup object file to it   using <code>ar65</code>.</p> </li> <li> <p><code>ld65</code>: The linker takes the object files, linker config file (<code>prog.cfg</code>),   and library, and produces the final <code>.COM</code> binary. A map file (<code>main.map</code>) is   also generated for inspection.</p> </li> <li> <p><code>clean</code>: Removes temporary and intermediate files.</p> </li> </ul>"},{"location":"software/building-programs/#why-use-supervisionlib","title":"Why Use <code>supervision.lib</code>?","text":"<p>The cc65 toolchain includes a number of prebuilt runtime libraries for different systems. <code>supervision.lib</code> is used here for the following reasons:</p> <ul> <li>It is one of the simplest and smallest libraries included with cc65.</li> <li>It provides basic C runtime support (e.g., <code>memcpy</code>, <code>strlen</code>, <code>memcmp</code>) without assuming the presence of I/O hardware or a full operating system.</li> <li>It is compatible with <code>-t none</code> and targets systems similar in simplicity to the ByteCradle SBC.</li> <li>Using this library, along with a custom <code>crt0.s</code> file, gives full control over how the program starts and runs.</li> </ul> <p>This approach avoids unnecessary dependencies and gives the developer direct control over memory layout, system initialization, and runtime behavior.</p>"},{"location":"software/building-programs/#deployment","title":"Deployment","text":"<p>This document outlines the deployment process for stand-alone programs on two distinct platforms: ByteCradle OS and TinyROM. While both systems are designed for simplicity and low-level control, they offer different approaches to program execution. ByteCradle OS provides a file-based interface that simplifies running compiled applications, whereas TinyROM offers a more hands-on experience, requiring direct memory interaction through a built-in monitor.</p> <p>Note</p> <p>ByteCradle OS uses the same monitor as TinyROM, so you can deploy programs using the TinyROM method (writing raw hex via the monitor) on ByteCradle OS as well.</p>"},{"location":"software/building-programs/#bytecradle-os","title":"ByteCradle OS","text":"<p>Deploying a stand-alone program on the ByteCradle OS is straightforward. Simply copy the compiled <code>.COM</code> file to the SD card used by the system. Once the card is mounted and the system is running, navigate to the appropriate directory using the shell, and type the base name of the file (without the <code>.COM</code> extension) to execute it. For example, if your file is named <code>HELLO.COM</code>, you can run it by typing <code>HELLO</code> at the prompt.</p> <p>An example is provided below:</p> <pre><code> ____             __           ____                      __   ___\n/\\  _`\\          /\\ \\__       /\\  _`\\                   /\\ \\ /\\_ \\\n\\ \\ \\L\\ \\  __  __\\ \\ ,_\\    __\\ \\ \\/\\_\\  _ __    __     \\_\\ \\\\//\\ \\      __\n \\ \\  _ &lt;'/\\ \\/\\ \\\\ \\ \\/  /'__`\\ \\ \\/_/_/\\`'__\\/'__`\\   /'_` \\ \\ \\ \\   /'__`\\\n  \\ \\ \\L\\ \\ \\ \\_\\ \\\\ \\ \\_/\\  __/\\ \\ \\L\\ \\ \\ \\//\\ \\L\\.\\_/\\ \\L\\ \\ \\_\\ \\_/\\  __/\n   \\ \\____/\\/`____ \\\\ \\__\\ \\____\\\\ \\____/\\ \\_\\\\ \\__/.\\_\\ \\___,_\\/\\____\\ \\____\\\n    \\/___/  `/___/&gt; \\\\/__/\\/____/ \\/___/  \\/_/ \\/__/\\/_/\\/__,_ /\\/____/\\/____/\n               /\\___/\n               \\/__/\n  ____  ______     __      ___\n /'___\\/\\  ___\\  /'__`\\  /'___`\\\n/\\ \\__/\\ \\ \\__/ /\\ \\/\\ \\/\\_\\ /\\ \\\n\\ \\  _``\\ \\___``\\ \\ \\ \\ \\/_/// /__\n \\ \\ \\L\\ \\/\\ \\L\\ \\ \\ \\_\\ \\ // /_\\ \\\n  \\ \\____/\\ \\____/\\ \\____//\\______/\n   \\/___/  \\/___/  \\/___/ \\/_____/\n\nStarting system.\nClearing user space...   [OK]\nConnecting to SD-card... [OK]\n:/&gt; ls\nFIBO    .COM 00000007 2302\nHELLO   .COM 00000008 23\nMANDEL  .COM 00000006 1406\n:/&gt; hello\nHello World!\n:/&gt;\n</code></pre>"},{"location":"software/building-programs/#tinyrom","title":"TinyROM","text":"<p>Deploying programs to the TinyROM system is a bit more involved than on ByteCradle OS. TinyROM relies on its built-in monitor for program loading. To begin, power on the system and access the monitor prompt. From there, type <code>W0800</code> to enter write mode starting at memory address <code>$0800</code>. In this mode, you'll input the raw machine code of your program as a continuous stream of hexadecimal values\u2014with no spaces or line breaks.</p> <p>For instance, to deploy a simple \"Hello World\" program, you would enter:</p> <pre><code>0008A90AA20820E8FF6048656C6C6F20576F726C642100\n</code></pre> <p>Tip</p> <p>Need the raw hex of an executable? On Linux, use this one-liner to dump it as a continuous stream of HEX characters: <code>hexdump -v -e '/1 \"%02X\"' HELLO.COM</code></p> <p>Warning</p> <p>When pasting \"large\" files (e.g., several hundred bytes), the ByteCradle system may struggle to keep up with the incoming data stream, leading to dropped or corrupted input. To prevent this, consider using terminal programs like Tera Term, which allow you to insert small delays between characters during transmission.</p> <p>After typing the entire sequence, press Enter to exit write mode. Then, to execute the program, type:</p> <pre><code>G0802\n</code></pre> <p>The result below shows how it should look like.</p> <pre><code>+----------------------------------------------+\n|             BYTECRADLE MONITOR               |\n+----------------------------------------------+\n| FREE ZERO PAGE :     0x40 - 0xFF             |\n| FREE RAM       : 0x0400 - 0x7F00             |\n| ROM            : 0x8000 - 0xFFFF             |\n+----------------------------------------------+\n| COMMANDS                                     |\n| R&lt;XXXX&gt;[:&lt;XXXX&gt;] read memory                 |\n| W&lt;XXXX&gt;          write to memory             |\n| G&lt;XXXX&gt;          run from address            |\n| A&lt;XXXX&gt;          assemble from address       |\n| D&lt;XXXX&gt;          disassemble from address    |\n| M                show this menu              |\n| Q                quit                        |\n+----------------------------------------------+\n\n@:W0800\n &gt; Enabling WRITE MODE. Enter HEX values. Hit RETURN to quit.\n    0800: 00 08 A9 0A A2 08 20 E8 FF 60 48 65 6C 6C 6F 20\n    0810: 57 6F 72 6C 64 21 00\n@:G0802\nHello World!\n\n@:\n</code></pre>"},{"location":"software/kernel-functions/","title":"Kernel functions","text":"<p>The system exposes a set of core kernel functions at fixed memory addresses located just below the 6502 vector table. This area is referred to as the jump table.</p> <p>Each jump table entry is a 3-byte <code>JMP</code> instruction that redirects to the actual implementation of a function. This design allows system programs and user applications to call kernel routines via stable, absolute addresses, regardless of where the underlying code is actually located.</p>"},{"location":"software/kernel-functions/#how-it-works","title":"How It Works","text":"<p>The jump table starts at address <code>$FFE5</code>, with each function occupying 3 bytes (the size of a <code>JMP</code> absolute instruction). For example:</p> <pre><code>jsr $FFE5  ; call putstr\n</code></pre> <p>This instruction jumps to the putstr routine, allowing the user to print a string without needing to know where putstr is implemented in memory. This makes the jump table a forward-compatible interface to the kernel.</p>"},{"location":"software/kernel-functions/#overview-jump-table","title":"Overview jump table","text":"<p>Below is an overview of currently available jump table entries:</p> Label Address Description Input Registers Garbled Registers <code>putstr</code> <code>$FFE5</code> Prints a null-terminated string. <code>X:A</code> = High:Low pointer to string <code>A</code>, <code>X</code>, <code>Y</code> <code>putstrnl</code> <code>$FFE8</code> Prints a null-terminated string followed by a CRLF. <code>X:A</code> = High:Low pointer to string <code>A</code>, <code>X</code>, <code>Y</code> <code>putch</code> <code>$FFEB</code> Outputs a single character to ACIA. <code>A</code> = Character None <code>newline</code> <code>$FFEE</code> Prints carriage return and line feed. - None <code>puthex</code> <code>$FFF1</code> Prints a byte in hexadecimal format. <code>A</code> = Byte to print None <code>putdec</code> <code>$FFF4</code> Prints a byte in decimal format. <code>A</code> = Byte to print <code>X</code>, <code>Y</code> <code>getch</code> <code>$FFF7</code> Retrieves a character from input buffer. \u2014 <code>A</code> <p>Note</p> <p>The jump table is exactly the same for both the  TINY and  MINI boards.</p> <p>Warning</p> <p>Garbled refers to CPU registers whose contents are modified or overwritten by a routine and are not restored before returning. This means the calling code should not rely on the original values of these registers after the routine executes.</p> <p>For example, if a function garbles register <code>X</code>, then any value that was in  <code>X</code> before the function call may be lost and should not be assumed valid  afterward. To preserve important register values across such calls, the  caller is responsible for saving and restoring them (e.g., using <code>PHA</code>,  <code>PHX</code>, <code>PHY</code> and their corresponding pull instructions).</p>"},{"location":"software/operating-system/","title":"Operating Systems","text":"<p>This page describes two minimalist operating systems: TINYROM, a ROM-based OS for the TINY board featuring a menu-driven interface without disk storage, and BCOS, a lightweight disk operating system for the MINI board providing basic file management and serial communication using familiar Linux-style commands.</p>"},{"location":"software/operating-system/#tinyrom-operating-system-tiny-board","title":"TINYROM operating system (TINY board)","text":""},{"location":"software/operating-system/#overview","title":"Overview","text":"<p>TINYROM is a minimalist ROM-based operating system and runtime environment for the  TINY board. It is designed to be as small and simple as possible, offering a bare-metal interface that boots directly into a menu-driven selector for launching built-in programs, test routines, and games \u2014 all stored within a compact 32 KiB ROM image.</p> <p>Unlike more complex operating systems that manage filesystems or dynamic storage (see below), TINYROM does not interface with disks or SD cards. Instead, it provides a tiny kernel consisting solely of  low-level I/O routines for communicating with the 65C51 ACIA serial interface. These routines allow basic input and output over a serial terminal and form the foundation for user interaction and debugging.</p> <p>Upon startup, TINYROM presents a static selection menu through the serial interface, enabling users to choose from a set of preloaded software \u2014 typically small utilities, diagnostics, or simple games.</p>"},{"location":"software/operating-system/#bytecradle-operating-system-mini-board","title":"ByteCradle Operating System (MINI board)","text":""},{"location":"software/operating-system/#overview_1","title":"Overview","text":"<p>The  MINI board runs on BCOS (ByteCradle Operating System), a minimalist, single-user disk operating system (SUDOS) purpose-built for the MINI. Designed with clarity, compactness, and practical utility in mind, BCOS offers essential functionality for persistent storage access and serial communication, without the complexity of multitasking or modern OS abstractions.</p> <p>At its core, BCOS presents a simple, navigable view of the SD card\u2019s contents, supporting basic file operations such as directory listing, file reading, writing, and \u2014 critically \u2014 the ability to load and execute binary programs directly from the SD card. This capability allows BCOS to serve as a lightweight but extensible platform for launching standalone applications with minimal runtime overhead.</p> <p>In addition to its command-line shell, BCOS exposes a set of  low-level I/O routines for working with the  65C51 ACIA serial interface. These include functions for reading characters, writing characters, and outputting entire strings over the serial port, enabling user programs to easily perform serial communication without reimplementing low-level logic.</p> <p>Communication via the 65C51 ACIA serves both as the user console and as a fundamental I/O channel, making BCOS suitable for both interactive and automated tasks on constrained 8-bit hardware.</p>"},{"location":"software/operating-system/#navigation","title":"Navigation","text":"<p>BCOS leverages common Linux-style commands for file and directory management, offering a familiar environment to users accustomed to Linux or UNIX systems. Below are examples of frequently used commands:</p> <ul> <li> <p>List directory contents (<code>ls</code>): To view the files and directories within   the current directory, simply type:   <pre><code>ls\n</code></pre></p> </li> <li> <p>Change directory (<code>cd</code>): To navigate to another directory, use:   <pre><code>cd dirname\n</code></pre>   For example, to move up one directory level:   <pre><code>cd ..\n</code></pre></p> </li> <li> <p>Executing programs: Executable files typically have a <code>.COM</code> extension. To   run these files, type their base name (without the <code>.COM</code> extension). For   instance, to execute a program named <code>MYAPP.COM</code>, simply type:   <pre><code>myapp\n</code></pre></p> </li> </ul> <p>Note</p> <p>While BCOS internally manages file names in uppercase, users may conveniently enter commands and file names in lowercase.</p>"},{"location":"software/software-overview/","title":"Software Overview","text":"\u2728 Operating System <p>Understand how the operating system manages tasks and interacts with the hardware.</p> \ud83d\udd27 Kernel Functions <p>Explore kernel-level functions that handle modularized input/output operations.</p> \ud83d\udee0\ufe0f Building Programs <p>Learn how to write, compile, and deploy C and assembly programs using the cc65 toolchain.</p>"},{"location":"tutorials/debugging/","title":"Debugging","text":""},{"location":"tutorials/hello-world-assembly/","title":"Tutorial: Hello World in Assembly","text":"<p>This tutorial walks you through writing, building, and running a simple \"Hello World\" program in 6502 assembly for the ByteCradle OS. The example uses the <code>cc65</code> toolchain, a widely used suite for 6502-based development.</p>"},{"location":"tutorials/hello-world-assembly/#step-1-writing-the-assembly-code","title":"Step 1: Writing the Assembly Code","text":"<p>Create a new file called <code>helloworld.asm</code> and enter the following code:</p> <pre><code>;------------------------------------------------------------------------------\n; Hello World Example for ByteCradle 6502\n;\n; This program prints \"Hello World!\" to the screen using the ByteCradle OS's\n; built-in output routine located at $FFE8.\n;------------------------------------------------------------------------------\n\n.PSC02                              ; Assembly for the 65C02 CPU\n\n.import __HEADER_LOAD__             ; Provided by the linker (.cfg) as load address\n\n.define PUTSTRNL $FFE8              ; Routine to print a null-terminated string with newline\n\n;------------------------------------------------------------------------------\n; Program Header (used by ByteCradle OS to determine deployment address)\n;------------------------------------------------------------------------------\n.segment \"HEADER\"\n.word __HEADER_LOAD__               ; Deployment address (typically $0800), little-endian\n\n;------------------------------------------------------------------------------\n; Main Code Segment\n;------------------------------------------------------------------------------\n.segment \"CODE\"\n\nstart:                              ; Entry point\n    lda #&lt;hwstr                     ; Load low byte of string address\n    ldx #&gt;hwstr                     ; Load high byte of string address\n    jsr PUTSTRNL                    ; Call OS routine to print string with newline\n    rts                             ; Return to OS\n\nhwstr:\n    .asciiz \"Hello World!\"          ; Null-terminated string\n</code></pre> <p>How it works:</p> <ul> <li>The program starts at the label start, which is called by the OS.</li> <li>It loads the address of a null-terminated string and calls    the OS function at   <code>$FFE8</code>, which prints the string followed by a newline.</li> <li>The .segment \"HEADER\" section includes a 2-byte deployment address required by   ByteCradle OS .COM files.</li> <li>The program ends with rts (return from subroutine), allowing the OS to regain   control.</li> </ul>"},{"location":"tutorials/hello-world-assembly/#step-2-writing-the-makefile","title":"Step 2: Writing the Makefile","text":"<p>Create a file called Makefile in the same directory:</p> <pre><code>PROG = HELLO.COM\nOBJ  = helloworld.o\nCFG  = rom.cfg\n\nall: $(PROG)\n\n$(OBJ): helloworld.asm\n    ca65 helloworld.asm -o $(OBJ)\n\n$(PROG): $(OBJ)\n    ld65 -o $(PROG) -C $(CFG) $(OBJ)\n</code></pre> <p>This Makefile automates the build process:</p> <ul> <li>Assembles the source using <code>ca65</code></li> <li>Links the program using <code>ld65</code> with a linker configuration file (<code>rom.cfg</code>)</li> <li>Produces an output file named <code>HELLO.COM</code></li> </ul>"},{"location":"tutorials/hello-world-assembly/#step-3-linker-configuration-romcfg","title":"Step 3: Linker Configuration (rom.cfg)","text":"<p>You will also need a linker configuration file called <code>rom.cfg</code>. This tells the linker how to place the code in memory:</p> <pre><code>MEMORY {\n    HEADER: start = $0800, size = 2, file = %O;             # Explicit start position\n    ROM:    start = $0802, size = $7FFE, file = %O;         # Start right after HEADER\n}\n\nSEGMENTS {\n    HEADER: load = HEADER, type = ro, define = yes;\n    CODE:   load = ROM, type = ro;\n}\n</code></pre> <p>This layout matches the expectations of the ByteCradle OS, which reads the first two bytes of a .COM file to determine where to load it into memory.</p>"},{"location":"tutorials/hello-world-assembly/#step-4-building-the-program","title":"Step 4: Building the Program","text":"<p>To compile and link your program, simply run:</p> <pre><code>make\n</code></pre> <p>This will produce a file called <code>HELLO.COM</code>, ready for deployment.</p> <p>Note</p> <p>The resulting <code>HELLO.COM</code> file is only 23 bytes in size, very small. This is because the program basically only contains an instruction for a kernel function and nothing more.</p>"},{"location":"tutorials/hello-world-assembly/#step-5-running-the-program","title":"Step 5: Running the Program","text":"<p>Copy <code>HELLO.COM</code> to the SD card used by the ByteCradle system.</p> <p>From the ByteCradle OS shell:</p> <ul> <li>Navigate to the folder containing the file using <code>cd</code>.</li> <li>Type the base name of the file (without the .COM extension):</li> </ul> <pre><code>hello\n</code></pre> <p>You should see:</p> <pre><code>Hello World!\n</code></pre> <p>Tip</p> <p>Instructions on how to deploy the program to your ByteCradle board are provided here</p>"},{"location":"tutorials/hello-world-c/","title":"Writing a Standalone C Program for ByteCradle with CC65","text":"<p>This tutorial walks through the process of building a standalone C program for the ByteCradle platform using the cc65 toolchain. You'll learn how to set up the startup code, write a simple <code>main()</code> function, configure memory mapping, and compile the final binary.</p> <p>Tip</p> <p>You can find several example programs in the official repository.</p>"},{"location":"tutorials/hello-world-c/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Linux system with the <code>cc65</code> toolchain installed (<code>ca65</code>, <code>cc65</code>, <code>ld65</code>, <code>ar65</code>)</li> <li>Basic familiarity with 6502 architecture and C programming</li> <li>Make and a standard build environment</li> </ul> <p>Tip</p> <p>More information on the toolchain is provided here.</p>"},{"location":"tutorials/hello-world-c/#project-structure","title":"Project Structure","text":"<p>The project consists of the following files:</p> File Description <code>crt0.s</code> Startup code (called before <code>main()</code>) <code>main.c</code> Your main application in C <code>io.h</code> Helper for system-level I/O routines <code>prog.cfg</code> Memory layout and segment configuration for the linker <code>Makefile</code> Automates the build process"},{"location":"tutorials/hello-world-c/#step-1-write-the-startup-code","title":"Step 1: Write the Startup Code","text":"<p>The startup assembly file initializes the stack, clears the BSS section, copies initialized data, and finally calls <code>main()</code>. It also defines an <code>_exit</code> routine for cleanup.</p> <pre><code>; ---------------------------------------------------------------------------\n; crt0.s\n; ---------------------------------------------------------------------------\n\n.import __HEADER_LOAD__                     ; import start location\n\n.export   _init, _exit\n.import   _main, _charout\n\n.export   __STARTUP__ : absolute = 1        ; Mark as startup\n.import   __RAM_START__, __RAM_SIZE__       ; Linker generated\n\n.import    copydata, zerobss, initlib, donelib\n\n.include  \"zeropage.inc\"\n\n; ---------------------------------------------------------------------------\n\n.segment \"HEADER\"\n\n.word __HEADER_LOAD__\n\n; ---------------------------------------------------------------------------\n\n.segment  \"STARTUP\"\n\n; ---------------------------------------------------------------------------\n; Set cc65 argument stack pointer\n; ---------------------------------------------------------------------------\n_init:\n\n          LDA     #&lt;(__RAM_START__ + __RAM_SIZE__)\n          STA     sp\n          LDA     #&gt;(__RAM_START__ + __RAM_SIZE__)\n          STA     sp+1\n\n; ---------------------------------------------------------------------------\n; Initialize memory storage\n; ---------------------------------------------------------------------------\n\n          JSR     zerobss              ; Clear BSS segment\n          JSR     copydata             ; Initialize DATA segment\n          JSR     initlib              ; Run constructors\n\n; ---------------------------------------------------------------------------\n; Call main()\n; ---------------------------------------------------------------------------\n\n          JSR     _main\n\n; ---------------------------------------------------------------------------\n; Back from main (this is also the _exit entry):  force a software break\n; ---------------------------------------------------------------------------\n\n_exit:    JSR     donelib              ; Run destructors\n          RTS\n</code></pre>"},{"location":"tutorials/hello-world-c/#step-2-create-io-header","title":"Step 2: Create I/O Header","text":"<p>This header declares a function pointer to the system's ROM-based string printing routine at address <code>$FFE8</code>. This lets us call system functions from C.</p> <pre><code>#ifndef _IO_H\n#define _IO_H\n\n#include &lt;stdint.h&gt;\n\n// ByteCradle OS: Print null-terminated string with newline (ROM $FFE8)\nvoid (*putstrnl)(const uint8_t*) = (void (*)(const uint8_t*))0xFFE8;\n\n#endif // _IO_H\n</code></pre>"},{"location":"tutorials/hello-world-c/#step-3-write-the-main-c-program","title":"Step 3: Write the Main C Program","text":"<p>This is a simple \"Hello World\" program that prints to the screen using <code>putstrnl</code>.</p> <pre><code>#include \"io.h\"\n\nint main() {\n    putstrnl(\"Hello World!\");\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/hello-world-c/#step-4-configure-memory-layout","title":"Step 4: Configure Memory Layout","text":"<p>The linker configuration (<code>prog.cfg</code>) defines where various sections of the program go in memory, including a 2-byte header, zero page usage, and stack space.</p> <pre><code>MEMORY {\n    ZP:     start = $50, size = $B0, type = rw, define = yes;\n    HEADER: start = $0800, size = 2, file = %O;\n    RAM:    start = $0802, size = $7700-$0802, type = rw, define = yes;\n    STACK:  start = $7700, size = $0800, type = rw, define = yes;\n}\n\nSEGMENTS {\n    ZEROPAGE: load = ZP,        type = zp,  define   = yes;\n    HEADER:   load = HEADER,    type = ro,  define   = yes;\n    STARTUP:  load = RAM,       type = ro;\n    CODE:     load = RAM,       type = ro;\n    ONCE:     load = RAM,       type = ro,  optional = yes;\n    RODATA:   load = RAM,       type = ro;\n    DATA:     load = RAM,       type = rw,  define   = yes, run = RAM;\n    BSS:      load = RAM,       type = bss, define   = yes;\n    HEAP:     load = RAM,       type = bss, optional = yes;\n}\n\nFEATURES {\n    CONDES:    segment = STARTUP,\n               type    = constructor,\n               label   = __CONSTRUCTOR_TABLE__,\n               count   = __CONSTRUCTOR_COUNT__;\n    CONDES:    segment = STARTUP,\n               type    = destructor,\n               label   = __DESTRUCTOR_TABLE__,\n               count   = __DESTRUCTOR_COUNT__;\n}\n\nSYMBOLS {\n    # Define the stack size for the application\n    __STACKSIZE__:  value = $0200, type = weak;\n}\n</code></pre>"},{"location":"tutorials/hello-world-c/#step-5-create-the-makefile","title":"Step 5: Create the Makefile","text":"<p>The <code>Makefile</code> automates the build by assembling and linking your C and assembly files into a <code>.COM</code> binary that can be run on ByteCradle.</p> <pre><code>PROG = HELLOC.COM\n\nall: $(PROG)\n\n$(PROG): prog.cfg crt0.o main.o prog.lib\n    ar65 a prog.lib crt0.o\n    ld65 -C prog.cfg -m main.map main.o -o $(PROG) prog.lib\n\ncrt0.o: crt0.s\n    ca65 --cpu 65c02 crt0.s\n\nmain.s: main.c\n    cc65 -t none -O --cpu 65c02 main.c\n\nprog.lib: crt0.o\n    cp -v /usr/share/cc65/lib/supervision.lib prog.lib \n    ar65 a prog.lib crt0.o\n\nmain.o: main.s\n    ca65 --cpu 65c02 main.s\n\nclean:\n    rm -v *.o *.lib main.s $(PROG)\n</code></pre>"},{"location":"tutorials/hello-world-c/#step-6-build-the-program","title":"Step 6: Build the Program","text":"<p>From the terminal, run:</p> <pre><code>make\n</code></pre>"},{"location":"tutorials/hello-world-c/#step-7-run-the-program","title":"Step 7: Run the program","text":"<p>Copy the resulting HELLOC.COM file to the ByteCradle's SD card or upload it using the appropriate method. Then, on the ByteCradle shell:</p> <pre><code>:/&gt; helloc\nHello World!\n:/&gt;\n</code></pre> <p>Tip</p> <p>Instructions on how to deploy the program to your ByteCradle board, including for the TinyROM which does not have an SD-CARD, are provided here</p>"},{"location":"tutorials/inline-assembler/","title":"Inline Assembler Tutorial","text":"<p>This section begins with a brief overview of the monitor and its role in the system, followed by a tutorial on how to use its inline assembler feature to build small, custom code snippets.</p>"},{"location":"tutorials/inline-assembler/#monitor","title":"Monitor","text":"<p>The monitor is a simple interactive program that gives you low-level control over the system\u2019s memory and CPU. It supports reading and writing memory, executing code at arbitrary addresses, disassembling machine instructions, and assembling new instructions directly from the command line using its built-in assembler.</p> <p>Note</p> <p>The description provided here pertains to the <code>/TINY/</code> board, but the instructions are transferable to the <code>/MINI/</code> board. The major difference is that the <code>/MINI/</code> board supports bank switching and has its ROM starting at <code>0xC000</code> where as the <code>/TINY/</code> has ROM starting at <code>0x8000</code>.</p> <p>Upon booting the <code>/TINY/</code> board, you will be greeted with a selection menu which allows you to select the <code>MONITOR</code> option. </p> <pre><code>+----------------------------------------------+\n|             BYTECRADLE MONITOR               |\n+----------------------------------------------+\n| FREE ZERO PAGE :     0x40 - 0xFF             |\n| FREE RAM       : 0x0400 - 0x7F00             |\n| ROM            : 0x8000 - 0xFFFF             |\n+----------------------------------------------+\n| COMMANDS                                     |\n| R&lt;XXXX&gt;[:&lt;XXXX&gt;] read memory                 |\n| W&lt;XXXX&gt;          write to memory             |\n| G&lt;XXXX&gt;          run from address            |\n| A&lt;XXXX&gt;          assemble from address       |\n| D&lt;XXXX&gt;          disassemble from address    |\n| M                show this menu              |\n| Q                quit                        |\n+----------------------------------------------+\n</code></pre>"},{"location":"tutorials/inline-assembler/#monitor-functions","title":"Monitor Functions","text":"<p>The Monitor provides several commands that allow direct interaction with the system's memory and CPU. These functions are essential for writing, testing, and debugging programs at a low level:</p> <ul> <li>Reading memory (<code>R&lt;XXXX&gt;[:&lt;XXXX&gt;]</code>) Allows you to examine memory contents at a   specific address or within a range of addresses.</li> <li>Writing to memory (<code>W&lt;XXXX&gt;</code>) Enables manual modification of memory contents at   a given address. Useful for inserting data like ASCII strings or instructions.</li> <li>Running code (<code>G&lt;XXXX&gt;</code>) Starts execution of code from a specific memory   address, enabling you to run programs you have written or loaded into RAM.</li> <li>Inline assembly (<code>A&lt;XXXX&gt;</code>) Opens an assembler interface at the specified   address, allowing you to input machine code instructions directly in mnemonic   form.</li> <li>Disassembling code (<code>D&lt;XXXX&gt;</code>) Reads machine code from memory and converts it   back into human-readable assembly instructions.</li> <li>Showing the menu (<code>M</code>) Displays the monitor\u2019s command menu and current memory   layout for quick reference.</li> <li>Quitting (<code>Q</code>) Exits the monitor and returns control to the system selection   menu or operating environment.</li> </ul> <p>These functions work together to provide a lightweight but powerful development environment directly on the hardware.</p>"},{"location":"tutorials/inline-assembler/#sample-programs","title":"Sample programs","text":"<p>The following examples demonstrate how to use the Monitor\u2019s inline assembler, memory writing, and program execution features. By manually assembling instructions and inserting data, you can create simple programs directly in memory and run them without needing external tools. These exercises are ideal for learning how the system interacts with memory and the CPU at a low level.</p>"},{"location":"tutorials/inline-assembler/#hello-world","title":"Hello World","text":"<p>Open the inline-assembler using <code>A0400</code> and insert the following assembly instructions:</p> <pre><code>0400: LDA #10       A9 10\n0402: LDX #04       A2 04\n0404: JSR FFE8      20 E8 FF\n0407: RTS           60\n</code></pre> <p>Next, insert the ASCII characters for the string <code>Hello World!</code> by first typing <code>W0410</code> and entering the following values:</p> <pre><code>0410: 48 65 6C 6C 6F 20 57 6F 72 6C 64 21 00\n</code></pre> <p>To run the small program, type <code>G0400</code>.</p> <p>The expected output is:</p> <pre><code>@:G0400\nHello World!\n</code></pre> <p>Note</p> <p>Observe that we used one of the kernel functions, <code>putch</code> located at <code>#FFE8</code> to output a single character to the ACIA. An overview of all the kernel functions can be found here.</p>"},{"location":"tutorials/inline-assembler/#fibonacci-series","title":"Fibonacci series","text":"<p>Open the inline-assembler using <code>A0400</code> and insert the following assembly instructions:</p> <pre><code>0400: LDA #01                  A9 01\n0402: LDX #01                  A2 01\n0404: LDY #00                  A0 00\n0406: PHX                      DA\n0407: PHY                      5A\n0408: JSR FFF4                 20 F4 FF\n040B: JSR FFEE                 20 EE FF\n040E: PLY                      7A\n040F: PLX                      FA\n0410: STX 40                   86 40\n0412: CLC                      18\n0413: PHA                      48\n0414: ADC 40                   65 40\n0416: PLX                      FA\n0417: INY                      C8\n0418: CPY #0C                  C0 0C\n041A: BNE EA                   D0 EA\n041C: RTS                      60\n</code></pre> <p>Note</p> <p>The value of <code>$40</code> used for <code>STX 40</code> and <code>ADC 40</code> refer to zero page address <code>$40</code>. Note that we are only allowed to use zero page addresses starting from <code>$40</code> as everything below is used by the system (including the monitor).</p> <p>To run the program, type <code>G0400</code>, which yields the following output:</p> <pre><code>@:G0400\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n</code></pre>"},{"location":"tutorials/overview/","title":"Tutorials","text":"\ud83e\udde9 Inline Assembler <p>Learn how to code 6502 directly on your ByteCradle Board using inline-assembler available via the Monitor.</p> \ud83d\udcdf Hello World (Assembly) <p>Write your first stand-alone 6502 program in pure assembly and run it on the ByteCradle platform.</p> \ud83d\udcac Hello World (C) <p>Create a minimal C program with cc65 and explore the basics of linking and deploying to ByteCradle.</p>"},{"location":"tutorials/peripherals/","title":"Working with peripherals","text":""}]}